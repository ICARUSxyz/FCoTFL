module DSCompiler  
var:  
  compilers: AtomicReference<DSCompiler[][]> = new AtomicReference(null)  

// Compiler instance retrieval  
process getCompiler(parameters: int, order: int) result: DSCompiler  
pre true  
post  
  cache = compilers.get()  
  cache ≠ null ∧ cache.length > parameters ∧ cache[parameters].length > order ∧ cache[parameters][order] ≠ null  
    → result' = cache[parameters][order]  
  else  
    maxParameters = FastMath.max(parameters, cache≠null ? cache.length : 0)  
    maxOrder = FastMath.max(order, cache≠null ? cache[0].length : 0)  
    newCache = new DSCompiler[maxParameters+1][maxOrder+1]  
    cache≠null  
      ? for i=0 to cache.length-1  
          System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length)  
    for diag=0 to parameters+order  
      o_min = FastMath.max(0, diag-parameters)  
      o_max = FastMath.min(order, diag)  
      for o=o_min to o_max  
        p = diag - o  
        newCache[p][o] = null  
          → valueCompiler = (p=0 ? null : newCache[p-1][o])  
            derivativeCompiler = (o=0 ? null : newCache[p][o-1])  
            newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler)  
    compilers.compareAndSet(cache, newCache)  
    result' = newCache[parameters][order]  
Functional Scenario Form  
cache exists with compiler for (2,3) && returns cached compiler  
no cache && creates new cache and compiler  
partial cache && expands cache diagonally  
end_process  

// Compiler constructor  
process constructor(parameters: int, order: int,  
                   valueCompiler: DSCompiler, derivativeCompiler: DSCompiler)  
pre true  
post  
  this.parameters' = parameters  
  this.order' = order  
  this.sizes' = compileSizes(parameters, order, valueCompiler)  
  this.derivativesIndirection' = compileDerivativesIndirection(parameters, order, valueCompiler, derivativeCompiler)  
  this.lowerIndirection' = compileLowerIndirection(parameters, order, valueCompiler, derivativeCompiler)  
  this.multIndirection' = compileMultiplicationIndirection(parameters, order, valueCompiler, derivativeCompiler, lowerIndirection)  
  this.compIndirection' = compileCompositionIndirection(parameters, order, valueCompiler, derivativeCompiler, sizes, derivativesIndirection)  
Functional Scenario Form  
parameters=2 order=3 && creates compiler with indirection arrays  
valueCompiler=null derivativeCompiler=null && handles base case  
end_process  

// Size compilation function  
function compileSizes(parameters: int, order: int, valueCompiler: DSCompiler) : int[][]  
pre true  
post  
  sizes = new int[parameters+1][order+1]  
  parameters = 0  
    ? ∀j:0≤j≤order → sizes[0][j] = 1  
    : System.arraycopy(valueCompiler.sizes, 0, sizes, 0, parameters)  
      sizes[parameters][0] = 1  
      for i=0 to order-1  
        sizes[parameters][i+1] = sizes[parameters][i] + sizes[parameters-1][i+1]  
  result' = sizes  
Functional Scenario Form  
parameters=0 order=3 && returns [[1,1,1,1]]  
parameters=2 order=2 valueCompiler has sizes=[[1,1,1],[1,2,3]] && returns [sizes[0],sizes[1],[1,2,4]]  
end_function  

// Derivatives indirection compilation  
function compileDerivativesIndirection(parameters: int, order: int,  
                                     valueCompiler: DSCompiler,  
                                     derivativeCompiler: DSCompiler) : int[][]  
pre true  
post  
  parameters=0 ∨ order=0 → result' = new int[1][parameters]  
  else  
    vSize = valueCompiler.derivativesIndirection.length  
    dSize = derivativeCompiler.derivativesIndirection.length  
    derivativesIndirection = new int[vSize+dSize][parameters]  
    for i=0 to vSize-1  
      System.arraycopy(valueCompiler.derivativesIndirection[i], 0,  
                      derivativesIndirection[i], 0, parameters-1)  
    for i=0 to dSize-1  
      System.arraycopy(derivativeCompiler.derivativesIndirection[i], 0,  
                      derivativesIndirection[vSize+i], 0, parameters)  
      derivativesIndirection[vSize+i][parameters-1]' =  
        derivativeCompiler.derivativesIndirection[i][parameters-1] + 1  
    result' = derivativesIndirection  
Functional Scenario Form  
parameters=2 order=1 valueCompiler=base derivativeCompiler=base  
  && returns combined indirection array with incremented last parameter  
end_function  

// Lower indirection compilation  
function compileLowerIndirection(parameters: int, order: int,  
                               valueCompiler: DSCompiler,  
                               derivativeCompiler: DSCompiler) : int[]  
pre true  
post  
  parameters=0 ∨ order≤1 → result' = [0]  
  else  
    vSize = valueCompiler.lowerIndirection.length  
    dSize = derivativeCompiler.lowerIndirection.length  
    lowerIndirection = new int[vSize+dSize]  
    System.arraycopy(valueCompiler.lowerIndirection, 0, lowerIndirection, 0, vSize)  
    for i=0 to dSize-1  
      lowerIndirection[vSize+i] = valueCompiler.getSize() + derivativeCompiler.lowerIndirection[i]  
    result' = lowerIndirection  
Functional Scenario Form  
parameters=2 order=2 valueCompiler=base derivativeCompiler=base  
  && returns combined lower indirection with offset  
end_function  

process compileMultiplicationIndirection(parameters: int, order: int,  
                                        valueCompiler: DSCompiler,  
                                        derivativeCompiler: DSCompiler,  
                                        lowerIndirection: int[]) : int[][][]  
pre true  
post  
  parameters=0 ∨ order=0 → result' = [[[1,0,0]]]  
  else  
    vSize = valueCompiler.multIndirection.length  
    dSize = derivativeCompiler.multIndirection.length  
    multIndirection = new int[vSize+dSize][][]  
    System.arraycopy(valueCompiler.multIndirection, 0, multIndirection, 0, vSize)  
    for i=0 to dSize-1  
      dRow = derivativeCompiler.multIndirection[i]  
      row = new ArrayList<int[]>()  
      for j=0 to dRow.length-1  
        row.add(new int[]{dRow[j][0], lowerIndirection[dRow[j][1]], vSize + dRow[j][2]})  
        row.add(new int[]{dRow[j][0], vSize + dRow[j][1], lowerIndirection[dRow[j][2]]})  
      combined = new ArrayList<int[]>()  
      for j=0 to row.size()-1  
        termJ = row.get(j)  
        termJ[0] > 0  
          for k=j+1 to row.size()-1  
            termK = row.get(k)  
            termJ[1] = termK[1] ∧ termJ[2] = termK[2]  
              termJ[0]' = termJ[0] + termK[0]  
              termK[0]' = 0  
          combined.add(termJ)  
      multIndirection[vSize+i] = combined.toArray()  
    result' = multIndirection  
Functional Scenario Form  
parameters=0 order=0 && returns [[[1,0,0]]]  
parameters=1 order=1 && returns combined multiplication rules  
derivativeCompiler row has 2 terms && generates 4 terms before combination  
matching index pairs in generated terms && combines coefficients 

end_process

// Composition indirection compilation  
process compileCompositionIndirection(parameters: int, order: int,  
                                     valueCompiler: DSCompiler,  
                                     derivativeCompiler: DSCompiler,  
                                     sizes: int[][],  
                                     derivativesIndirection: int[][]) : int[][][]  
pre true  
post  
  parameters=0 ∨ order=0 → result' = [[[1,0]]]  
  else  
    vSize = valueCompiler.compIndirection.length  
    dSize = derivativeCompiler.compIndirection.length  
    compIndirection = new int[vSize+dSize][][]  
    System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize)  
    for i=0 to dSize-1  
      row = new ArrayList<int[]>()  
      for each term in derivativeCompiler.compIndirection[i]  
        derivedTermF = new int[term.length+1]  
        derivedTermF[0] = term[0]  
        derivedTermF[1] = term[1] + 1  
        orders = new int[parameters]  
        orders[parameters-1] = 1  
        derivedTermF[term.length] = getPartialDerivativeIndex(parameters, order, sizes, orders)  
        for j=2 to term.length-1  
          derivedTermF[j] = convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes)  
        Arrays.sort(derivedTermF, 2, derivedTermF.length)  
        row.add(derivedTermF)  
        for l=2 to term.length-1  
          derivedTermG = new int[term.length]  
          derivedTermG[0] = term[0]  
          derivedTermG[1] = term[1]  
          for j=2 to term.length-1  
            derivedTermG[j] = convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes)  
            j=l  
              orders = derivativesIndirection[derivedTermG[j]]  
              orders[parameters-1]' = orders[parameters-1] + 1  
              derivedTermG[j] = getPartialDerivativeIndex(parameters, order, sizes, orders)  
          Arrays.sort(derivedTermG, 2, derivedTermG.length)  
          row.add(derivedTermG)  
      combined = new ArrayList<int[]>()  
      for j=0 to row.size()-1  
        termJ = row.get(j)  
        termJ[0] > 0  
          for k=j+1 to row.size()-1  
            termK = row.get(k)  
            termJ.length = termK.length  
            ∀m≥1: termJ[m] = termK[m]  
              termJ[0]' = termJ[0] + termK[0]  
              termK[0]' = 0  
          combined.add(termJ)  
      compIndirection[vSize+i] = combined.toArray()  
    result' = compIndirection  
Functional Scenario Form  
parameters=0 order=0 && returns [[[1,0]]]  
parameters=1 order=1 && processes derivativeCompiler rules  
derivativeCompiler term with length=3 && generates derived terms  
matching terms in row && combines coefficients  
end_process  

// Public partial derivative index access  
process getPartialDerivativeIndex(orders: int[]) result: int  
pre true  
post  
  orders.length ≠ parameters  
    → throw DimensionMismatchException(orders.length, parameters)  
  else  
    result' = static_getPartialDerivativeIndex(parameters, order, sizes, orders)  
Functional Scenario Form  
orders=[0,1] for parameters=2 && returns valid index  
orders.length=3 for parameters=2 && throws exception  
end_process  

// Static partial derivative index calculation  
process static_getPartialDerivativeIndex(parameters: int, order: int,  
                                        sizes: int[][], orders: int[]) result: int  
pre true  
post  
  index = 0  
  m = order  
  ordersSum = 0  
  for i=parameters-1 downto 0  
    ordersSum += orders[i]  
    ordersSum > order → throw NumberIsTooLargeException(ordersSum, order)  
    derivativeOrder = orders[i]  
    while derivativeOrder > 0  
      index += sizes[i][m]  
      m = m - 1  
      derivativeOrder = derivativeOrder - 1  
  result' = index  
Functional Scenario Form  
parameters=2 order=2 orders=[1,1] && returns valid index  
orders=[3,0] for order=2 && throws NumberIsTooLargeException  
end_process  

// Index conversion  
process convertIndex(index: int, srcP: int,  
                    srcDerivativesIndirection: int[][],  
                    destP: int, destO: int,  
                    destSizes: int[][]) result: int  
pre true  
post  
  orders = new int[destP]  
  System.arraycopy(srcDerivativesIndirection[index], 0, orders, 0, min(srcP, destP))  
  result' = static_getPartialDerivativeIndex(destP, destO, destSizes, orders)  
Functional Scenario Form  
valid index && returns converted index  
end_process  

// Partial derivative orders access  
process getPartialDerivativeOrders(index: int) result: int[]  
pre true  
post  
  result' = derivativesIndirection[index]  
end_process  

// Free parameters access  
process getFreeParameters() result: int  
pre true  
post  
  result' = parameters  
end_process  

// Order access  
process getOrder() result: int  
pre true  
post  
  result' = order  
end_process  

// Size access  
process getSize() result: int  
pre true  
post  
  result' = sizes[parameters][order]  
end_process  

// Linear combination (2 terms)  
process linearCombination2(a1: double, c1: double[], offset1: int,  
                          a2: double, c2: double[], offset2: int,  
                          result: double[], resultOffset: int)  
pre true  
post  
  size = getSize()  
  for i=0 to size-1  
    result[resultOffset+i] = MathArrays.linearCombination(a1, c1[offset1+i], a2, c2[offset2+i])  
Functional Scenario Form  
valid inputs && computes linear combination  
end_process  

// Linear combination (3 terms)  
process linearCombination3(a1: double, c1: double[], offset1: int,  
                          a2: double, c2: double[], offset2: int,  
                          a3: double, c3: double[], offset3: int,  
                          result: double[], resultOffset: int)  
pre true  
post  
  size = getSize()  
  for i=0 to size-1  
    result[resultOffset+i] = MathArrays.linearCombination(a1, c1[offset1+i],  
                                                          a2, c2[offset2+i],  
                                                          a3, c3[offset3+i])  
Functional Scenario Form  
three term combination && computes result  
end_process  

// Linear combination (4 terms)  
process linearCombination4(a1: double, c1: double[], offset1: int,  
                          a2: double, c2: double[], offset2: int,  
                          a3: double, c3: double[], offset3: int,  
                          a4: double, c4: double[], offset4: int,  
                          result: double[], resultOffset: int)  
pre true  
post  
  size = getSize()  
  for i=0 to size-1  
    result[resultOffset+i] = MathArrays.linearCombination(a1, c1[offset1+i],  
                                                          a2, c2[offset2+i],  
                                                          a3, c3[offset3+i],  
                                                          a4, c4[offset4+i])  
Functional Scenario Form  
four term combination && computes result  
end_process  

// Addition  
process add(lhs: double[], lhsOffset: int,  
            rhs: double[], rhsOffset: int,  
            result: double[], resultOffset: int)  
pre true  
post  
  for i=0 to getSize()-1  
    result[resultOffset+i] = lhs[lhsOffset+i] + rhs[rhsOffset+i]  
Functional Scenario Form  
size=3 && computes element-wise sum  
end_process  

// Subtraction  
process subtract(lhs: double[], lhsOffset: int,  
                 rhs: double[], rhsOffset: int,  
                 result: double[], resultOffset: int)  
pre true  
post  
  for i=0 to getSize()-1  
    result[resultOffset+i] = lhs[lhsOffset+i] - rhs[rhsOffset+i]  
Functional Scenario Form  
size=3 && computes element-wise difference  
end_process  

// Multiplication  
process multiply(lhs: double[], lhsOffset: int,  
                  rhs: double[], rhsOffset: int,  
                  result: double[], resultOffset: int)  
pre true  
post  
  for i=0 to multIndirection.length-1  
    mappingI = multIndirection[i]  
    r = 0  
    for j=0 to mappingI.length-1  
      r += mappingI[j][0] *  
           lhs[lhsOffset + mappingI[j][1]] *  
           rhs[rhsOffset + mappingI[j][2]]  
    result[resultOffset+i] = r  
Functional Scenario Form  
multIndirection with 2 terms && computes product correctly  
end_process  

// Division  
process divide(lhs: double[], lhsOffset: int,  
               rhs: double[], rhsOffset: int,  
               result: double[], resultOffset: int)  
pre true  
post  
  reciprocal = new double[getSize()]  
  pow(rhs, rhsOffset, -1, reciprocal, 0)  
  multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset)  
Functional Scenario Form  
valid inputs && computes quotient via reciprocal  
end_process  

// Remainder  
process remainder(lhs: double[], lhsOffset: int,  
                  rhs: double[], rhsOffset: int,  
                  result: double[], resultOffset: int)  
pre true  
post  
  rem = lhs[lhsOffset] % rhs[rhsOffset]  
  k = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset])  
  result[resultOffset] = rem  
  for i=1 to getSize()-1  
    result[resultOffset+i] = lhs[lhsOffset+i] - k * rhs[rhsOffset+i]  
Functional Scenario Form  
first-order only && computes remainder  
end_process  

// Power (double exponent)  
process pow_double(operand: double[], operandOffset: int, p: double,  
                   result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  xk = FastMath.pow(operand[operandOffset], p - order)  
  for i=order downto 1  
    function[i] = xk  
    xk *= operand[operandOffset]  
  function[0] = xk  
  coefficient = p  
  for i=1 to order  
    function[i] *= coefficient  
    coefficient *= p - i  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
p=2.5 && computes power function  
end_process  

// Power (integer exponent)  
process pow_int(operand: double[], operandOffset: int, n: int,  
                result: double[], resultOffset: int)  
pre true  
post  
  n=0  
    ? result[resultOffset] = 1.0  
      ∀i≥1: result[resultOffset+i] = 0  
  else  
    function = new double[1+order]  
    n>0  
      ? maxOrder = min(order, n)  
        xk = FastMath.pow(operand[operandOffset], n - maxOrder)  
        for i=maxOrder downto 1  
          function[i] = xk  
          xk *= operand[operandOffset]  
        function[0] = xk  
      : inv = 1.0 / operand[operandOffset]  
        xk = FastMath.pow(inv, -n)  
        for i=0 to order  
          function[i] = xk  
          xk *= inv  
    coefficient = n  
    for i=1 to order  
      function[i] *= coefficient  
      coefficient *= n - i  
    compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
n=0 && sets result to 1 with zero derivatives  
n=3 && computes positive power  
n=-2 && computes reciprocal power  
end_process  

// Power (x^y)  
process pow_xy(x: double[], xOffset: int,  
               y: double[], yOffset: int,  
               result: double[], resultOffset: int)  
pre true  
post  
  logX = new double[getSize()]  
  log(x, xOffset, logX, 0)  
  yLogX = new double[getSize()]  
  multiply(logX, 0, y, yOffset, yLogX, 0)  
  exp(yLogX, 0, result, resultOffset)  
Functional Scenario Form  
valid inputs && computes x^y via log-multiply-exp  
end_process  

// Nth root  
process rootN(operand: double[], operandOffset: int, n: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  n=2  
    ? function[0] = FastMath.sqrt(operand[operandOffset])  
      xk = 0.5 / function[0]  
  n=3  
    ? function[0] = FastMath.cbrt(operand[operandOffset])  
      xk = 1.0/(3.0*function[0]*function[0])  
  else  
    function[0] = FastMath.pow(operand[operandOffset], 1.0/n)  
    xk = 1.0/(n * FastMath.pow(function[0], n-1))  
  nReciprocal = 1.0/n  
  xReciprocal = 1.0/operand[operandOffset]  
  for i=1 to order  
    function[i] = xk  
    xk *= xReciprocal * (nReciprocal - i)  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
n=2 && computes square root  
n=4 && computes fourth root  
end_process  

// Exponential  
process exp(operand: double[], operandOffset: int,  
            result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  Arrays.fill(function, FastMath.exp(operand[operandOffset]))  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
valid input && computes e^x  
end_process  

// Exponential minus 1  
process expm1(operand: double[], operandOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.expm1(operand[operandOffset])  
  Arrays.fill(function, 1, 1+order, FastMath.exp(operand[operandOffset]))  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
valid input && computes e^x - 1  
end_process  

// Natural logarithm  
process log(operand: double[], operandOffset: int,  
            result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.log(operand[operandOffset])  
  order>0  
    ? inv = 1.0/operand[operandOffset]  
      xk = inv  
      for i=1 to order  
        function[i] = xk  
        xk *= -i * inv  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
valid input && computes ln(x)  
end_process  

// Logarithm (1+x)  
process log1p(operand: double[], operandOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.log1p(operand[operandOffset])  
  order>0  
    ? inv = 1.0/(1.0 + operand[operandOffset])  
      xk = inv  
      for i=1 to order  
        function[i] = xk  
        xk *= -i * inv  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
valid input && computes ln(1+x)  
end_process  

// Base-10 logarithm  
process log10(operand: double[], operandOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.log10(operand[operandOffset])  
  order>0  
    ? inv = 1.0/operand[operandOffset]  
      xk = inv / FastMath.log(10.0)  
      for i=1 to order  
        function[i] = xk  
        xk *= -i * inv  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
valid input && computes log10(x)  
end_process  

// Cosine  
process cos(operand: double[], operandOffset: int,  
            result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.cos(operand[operandOffset])  
  order>0  
    ? function[1] = -FastMath.sin(operand[operandOffset])  
      for i=2 to order  
        function[i] = -function[i-2]  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
order=0 && stores cosine value  
order=3 && generates [cos, -sin, -cos, sin]  
end_process  

// Sine  
process sin(operand: double[], operandOffset: int,  
            result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.sin(operand[operandOffset])  
  order>0  
    ? function[1] = FastMath.cos(operand[operandOffset])  
      for i=2 to order  
        function[i] = -function[i-2]  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
order=0 && stores sine value  
order=3 && generates [sin, cos, -sin, -cos]  
end_process  

// Tangent  
process tan(operand: double[], operandOffset: int,  
            result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  t = FastMath.tan(operand[operandOffset])  
  function[0] = t  
  order>0  
    ? p = new double[order+2]  
      p[1] = 1  
      t2 = t*t  
      for n=1 to order  
        v = 0  
        p[n+1] = n * p[n]  
        for k=n+1 downto 0 step -2  
          v = v*t2 + p[k]  
          k>2  
            ? p[k-2] = (k-1)*p[k-1] + (k-3)*p[k-3]  
          k=2  
            ? p[0] = p[1]  
        (n & 1) = 0  
          ? v *= t  
        function[n] = v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
order=1 && computes [tan, sec^2]  
end_process  

// Arccosine  
process acos(operand: double[], operandOffset: int,  
             result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  x = operand[operandOffset]  
  function[0] = FastMath.acos(x)  
  order>0  
    ? p = new double[order]  
      p[0] = -1  
      x2 = x*x  
      f = 1.0/(1-x2)  
      coeff = FastMath.sqrt(f)  
      function[1] = coeff * p[0]  
      for n=2 to order  
        v = 0  
        p[n-1] = (n-1)*p[n-2]  
        for k=n-1 downto 0 step -2  
          v = v*x2 + p[k]  
          k>2  
            ? p[k-2] = (k-1)*p[k-1] + (2*n-k)*p[k-3]  
          k=2  
            ? p[0] = p[1]  
        (n & 1) = 0  
          ? v *= x  
        coeff *= f  
        function[n] = coeff * v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
order=1 && computes [acos, -1/sqrt(1-x^2)]  
end_process  

// Arcsine  
process asin(operand: double[], operandOffset: int,  
             result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  x = operand[operandOffset]  
  function[0] = FastMath.asin(x)  
  order>0  
    ? p = new double[order]  
      p[0] = 1  
      x2 = x*x  
      f = 1.0/(1-x2)  
      coeff = FastMath.sqrt(f)  
      function[1] = coeff * p[0]  
      for n=2 to order  
        v = 0  
        p[n-1] = (n-1)*p[n-2]  
        for k=n-1 downto 0 step -2  
          v = v*x2 + p[k]  
          k>2  
            ? p[k-2] = (k-1)*p[k-1] + (2*n-k)*p[k-3]  
          k=2  
            ? p[0] = p[1]  
        (n & 1) = 0  
          ? v *= x  
        coeff *= f  
        function[n] = coeff * v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
x=0 order=1 && generates [0, 1]  
x=0.5 order=2 && computes derivatives  
end_process  

// Arctangent  
process atan(operand: double[], operandOffset: int,  
             result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  x = operand[operandOffset]  
  function[0] = FastMath.atan(x)  
  order>0  
    ? q = new double[order]  
      q[0] = 1  
      x2 = x*x  
      f = 1.0/(1+x2)  
      coeff = f  
      function[1] = coeff * q[0]  
      for n=2 to order  
        v = 0  
        q[n-1] = -n * q[n-2]  
        for k=n-1 downto 0 step -2  
          v = v*x2 + q[k]  
          k>2  
            ? q[k-2] = (k-1)*q[k-1] + (k-1-2*n)*q[k-3]  
          k=2  
            ? q[0] = q[1]  
        (n & 1) = 0  
          ? v *= x  
        coeff *= f  
        function[n] = coeff * v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
x=0 order=1 && generates [0, 1]  
x=1 order=2 && computes derivatives  
end_process  

// Two-argument arctangent  
process atan2(y: double[], yOffset: int,  
              x: double[], xOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  tmp1 = new double[getSize()]  
  multiply(x, xOffset, x, xOffset, tmp1, 0)  // x²  
  tmp2 = new double[getSize()]  
  multiply(y, yOffset, y, yOffset, tmp2, 0)  // y²  
  add(tmp1, 0, tmp2, 0, tmp2, 0)           // x² + y²  
  rootN(tmp2, 0, 2, tmp1, 0)              // r = √(x² + y²)  
  x[xOffset] ≥ 0  
    ? add(tmp1, 0, x, xOffset, tmp2, 0)    // r + x  
      divide(y, yOffset, tmp2, 0, tmp1, 0) // y/(r+x)  
      atan(tmp1, 0, tmp2, 0)              // atan(y/(r+x))  
      for i=0 to tmp2.length-1  
        result[resultOffset+i] = 2 * tmp2[i]  
  else  
    subtract(tmp1, 0, x, xOffset, tmp2, 0) // r - x  
    divide(y, yOffset, tmp2, 0, tmp1, 0)    // y/(r-x)  
    atan(tmp1, 0, tmp2, 0)                // atan(y/(r-x))  
    result[resultOffset] = (tmp2[0] ≤ 0 ? -π : π) - 2 * tmp2[0]  
    for i=1 to tmp2.length-1  
      result[resultOffset+i] = -2 * tmp2[i]  
  // Ensure correct value at origin  
  result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset])  
Functional Scenario Form  
x=1 y=0 && computes 0  
x=-1 y=0 && computes π  
x=0 y=1 && computes π/2  
end_process  

// Hyperbolic cosine  
process cosh(operand: double[], operandOffset: int,  
             result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.cosh(operand[operandOffset])  
  order>0  
    ? function[1] = FastMath.sinh(operand[operandOffset])  
      for i=2 to order  
        function[i] = function[i-2]  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
order=0 && stores cosh value  
order=3 && generates [cosh, sinh, cosh, sinh]  
end_process  

// Hyperbolic sine  
process sinh(operand: double[], operandOffset: int,  
             result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  function[0] = FastMath.sinh(operand[operandOffset])  
  order>0  
    ? function[1] = FastMath.cosh(operand[operandOffset])  
      for i=2 to order  
        function[i] = function[i-2]  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
order=0 && stores sinh value  
order=3 && generates [sinh, cosh, sinh, cosh]  
end_process  

// Hyperbolic tangent  
process tanh(operand: double[], operandOffset: int,  
             result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  t = FastMath.tanh(operand[operandOffset])  
  function[0] = t  
  order>0  
    ? p = new double[order+2]  
      p[1] = 1  
      t2 = t*t  
      for n=1 to order  
        v = 0  
        p[n+1] = -n * p[n]  
        for k=n+1 downto 0 step -2  
          v = v*t2 + p[k]  
          k>2  
            ? p[k-2] = (k-1)*p[k-1] - (k-3)*p[k-3]  
          k=2  
            ? p[0] = p[1]  
        (n & 1) = 0  
          ? v *= t  
        function[n] = v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
x=0 order=1 && generates [0, 1]  
x=1 order=2 && computes derivatives  
end_process  

// Hyperbolic arc cosine  
process acosh(operand: double[], operandOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  x = operand[operandOffset]  
  function[0] = FastMath.acosh(x)  
  order>0  
    ? p = new double[order]  
      p[0] = 1  
      x2 = x*x  
      f = 1.0/(x2-1)  
      coeff = FastMath.sqrt(f)  
      function[1] = coeff * p[0]  
      for n=2 to order  
        v = 0  
        p[n-1] = (1-n)*p[n-2]  
        for k=n-1 downto 0 step -2  
          v = v*x2 + p[k]  
          k>2  
            ? p[k-2] = (1-k)*p[k-1] + (k-2*n)*p[k-3]  
          k=2  
            ? p[0] = -p[1]  
        (n & 1) = 0  
          ? v *= x  
        coeff *= f  
        function[n] = coeff * v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
x=2 order=1 && generates [acosh(2), 1/√3]  
end_process  

// Hyperbolic arc sine  
process asinh(operand: double[], operandOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  x = operand[operandOffset]  
  function[0] = FastMath.asinh(x)  
  order>0  
    ? p = new double[order]  
      p[0] = 1  
      x2 = x*x  
      f = 1.0/(1+x2)  
      coeff = FastMath.sqrt(f)  
      function[1] = coeff * p[0]  
      for n=2 to order  
        v = 0  
        p[n-1] = (1-n)*p[n-2]  
        for k=n-1 downto 0 step -2  
          v = v*x2 + p[k]  
          k>2  
            ? p[k-2] = (k-1)*p[k-1] + (k-2*n)*p[k-3]  
          k=2  
            ? p[0] = p[1]  
        (n & 1) = 0  
          ? v *= x  
        coeff *= f  
        function[n] = coeff * v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
x=0 order=1 && generates [0, 1]  
x=1 order=2 && computes derivatives  
end_process  

// Hyperbolic arc tangent  
process atanh(operand: double[], operandOffset: int,  
              result: double[], resultOffset: int)  
pre true  
post  
  function = new double[1+order]  
  x = operand[operandOffset]  
  function[0] = FastMath.atanh(x)  
  order>0  
    ? q = new double[order]  
      q[0] = 1  
      x2 = x*x  
      f = 1.0/(1-x2)  
      coeff = f  
      function[1] = coeff * q[0]  
      for n=2 to order  
        v = 0  
        q[n-1] = n * q[n-2]  
        for k=n-1 downto 0 step -2  
          v = v*x2 + q[k]  
          k>2  
            ? q[k-2] = (k-1)*q[k-1] + (2*n-k+1)*q[k-3]  
          k=2  
            ? q[0] = q[1]  
        (n & 1) = 0  
          ? v *= x  
        coeff *= f  
        function[n] = coeff * v  
  compose(operand, operandOffset, function, result, resultOffset)  
Functional Scenario Form  
x=0 order=1 && generates [0, 1]  
x=0.5 order=2 && computes derivatives  
end_process  

// Function composition  
process compose(operand: double[], operandOffset: int, f: double[],  
                result: double[], resultOffset: int)  
pre true  
post  
  for i=0 to compIndirection.length-1  
    mappingI = compIndirection[i]  
    r = 0  
    for j=0 to mappingI.length-1  
      mappingIJ = mappingI[j]  
      product = mappingIJ[0] * f[mappingIJ[1]]  
      for k=2 to mappingIJ.length-1  
        product *= operand[operandOffset + mappingIJ[k]]  
      r += product  
    result[resultOffset+i] = r  
Functional Scenario Form  
constant function && propagates derivatives  
linear function && applies chain rule  
end_process  

// Taylor expansion  
process taylor(ds: double[], dsOffset: int, delta: double[]) result: double  
pre true  
post  
  value = 0  
  for i=getSize()-1 downto 0  
    orders = getPartialDerivativeOrders(i)  
    term = ds[dsOffset+i]  
    for k=0 to parameters-1  
      orders[k] > 0  
        ? term *= FastMath.pow(delta[k], orders[k]) / factorial(orders[k])  
    value += term  
  result' = value  
Functional Scenario Form  
delta=0 && returns ds[0]  
linear function && matches first-order approximation  
end_process  

// Compatibility check  
process checkCompatibility(compiler: DSCompiler)  
pre true  
post  
  parameters ≠ compiler.parameters → throw DimensionMismatchException  
  order ≠ compiler.order → throw DimensionMismatchException  
Functional Scenario Form  
same parameters and order && no exception  
different parameters && throws exception  
end_process  


end_module