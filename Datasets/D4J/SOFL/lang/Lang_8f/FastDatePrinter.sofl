module FastDatePrinter

type
  pattern: sequence of char,
  timeZone: TimeZone,
  locale: Locale,
  result: FastDatePrinter,
  rulesList: sequence of Rule,
  token: sequence of char,
  indexRef: sequence of int,
  parsedToken: sequence of char,
  rule: Rule,
  rules: sequence of Rule,
  field: int,
  padding: int,
  selected: NumberRule
  buffer: StringBuffer,
  calendar: Calendar,
  value: int,
  rule: NumberRule,
  tz: TimeZone,
  daylight: Boolean,
  style: int,
  locale: Locale,
  result: sequence of char,
  key: TimeZoneDisplayKey,
  zone: TimeZone

process FastDatePrinterConstructor(pattern: sequence of char, timeZone: TimeZone, locale: Locale) result: FastDatePrinter
pre
  pattern ≠ null ∧ timeZone ≠ null ∧ locale ≠ null
post
  result.mPattern = pattern &&
  result.mTimeZone = timeZone &&
  result.mLocale = locale &&
  result.mRules = parsePattern(pattern, locale) &&
  result.mMaxLengthEstimate = sum of estimateLength(mRules[i])
Functional Scenario Form
  (valid pattern, timeZone, locale) &&
    (result initialized with pattern, timeZone, locale and parsed rules)
end_process

process parsePattern() result: sequence of Rule
pre
  true
post
  result = rules generated by interpreting mPattern using locale-specific symbols &&
  ∀ r ∈ result. r is matched from valid pattern token
Functional Scenario Form
  (mPattern contains valid SimpleDateFormat-compatible pattern) &&
    (result = rule list mapping each pattern letter to Rule)
end_process

process parseToken(pattern: sequence of char, indexRef: sequence of int) result: sequence of char
pre
  0 ≤ indexRef[0] < |pattern|
post
  if pattern[indexRef[0]] is letter → result = run of same letters &&
  if pattern[indexRef[0]] is literal → result = quoted literal token &&
  indexRef[0] updated to last parsed character position
Functional Scenario Form
  (current char is letter) && result = consecutive letters or
  (current char is quote) && result = literal string block
end_process

process selectNumberRule(field: int, padding: int) result: NumberRule
pre
  padding ≥ 1
post
  (padding = 1) → result = UnpaddedNumberField(field) &&
  (padding = 2) → result = TwoDigitNumberField(field) &&
  (padding ≥ 3) → result = PaddedNumberField(field, padding)
Functional Scenario Form
  (padding = 1) && result = UnpaddedNumberField or
  (padding = 2) && result = TwoDigitNumberField or
  (padding ≥ 3) && result = PaddedNumberField
end_process


process format(obj: Object, toAppendTo: StringBuffer, pos: FieldPosition) result: StringBuffer
pre
  toAppendTo ≠ null
post
  (obj is Date) → result = format((Date) obj, toAppendTo) &&
  (obj is Calendar) → result = format((Calendar) obj, toAppendTo) &&
  (obj is Long) → result = format((Long) obj, toAppendTo) &&
  (otherwise) → throws IllegalArgumentException
Functional Scenario Form
  (obj is Date) && result = formatted date or
  (obj is Calendar) && result = formatted calendar or
  (obj is Long) && result = formatted date from millis or
  (obj is unknown) && throws IllegalArgumentException
end_process

process format(millis: long) result: String
pre
  true
post
  result = format(new Date(millis))
Functional Scenario Form
  (always true) && result = formatted string of Date(millis)
end_process

process format(date: Date) result: String
pre
  date ≠ null
post
  result = applyRules(GregorianCalendar(mTimeZone, mLocale) set to date, new StringBuffer)
Functional Scenario Form
  (valid date) && result = pattern-applied string from date
end_process

process format(calendar: Calendar) result: String
pre
  calendar ≠ null
post
  result = applyRules(calendar, new StringBuffer)
Functional Scenario Form
  (valid calendar) && result = pattern-applied string from calendar
end_process

process format(millis: long, buf: StringBuffer) result: StringBuffer
pre
  buf ≠ null
post
  result = format(new Date(millis), buf)
Functional Scenario Form
  (always true) && result = formatted millis in buf
end_process

process format(date: Date, buf: StringBuffer) result: StringBuffer
pre
  buf ≠ null ∧ date ≠ null
post
  result = applyRules(GregorianCalendar set to date, buf)
Functional Scenario Form
  (valid date and buffer) && result = filled buffer with formatted string
end_process

process format(calendar: Calendar, buf: StringBuffer) result: StringBuffer
pre
  buf ≠ null ∧ calendar ≠ null
post
  result = applyRules(calendar, buf)
Functional Scenario Form
  (valid calendar and buffer) && result = filled buffer with formatted calendar
end_process

process applyRules(calendar: Calendar, buf: StringBuffer) result: StringBuffer
pre
  calendar ≠ null ∧ buf ≠ null
post
  result = buf after appending all rule-formatted segments from calendar
Functional Scenario Form
  (calendar and buf not null) && result = buf with formatted content
end_process

process getPattern() result: String
pre
  true
post
  result = mPattern
Functional Scenario Form
  (always true) && result = mPattern
end_process

process getTimeZone() result: TimeZone
pre
  true
post
  result = mTimeZone
Functional Scenario Form
  (always true) && result = mTimeZone
end_process

process getLocale() result: Locale
pre
  true
post
  result = mLocale
Functional Scenario Form
  (always true) && result = mLocale
end_process

process getMaxLengthEstimate() result: int
pre
  true
post
  result = mMaxLengthEstimate
Functional Scenario Form
  (always true) && result = max estimated pattern length
end_process

process equals(obj: Object) result: boolean
pre
  true
post
  (obj is not FastDatePrinter) → result = false &&
  (obj is FastDatePrinter) →
    result = (mPattern = obj.mPattern ∧ mTimeZone = obj.mTimeZone ∧ mLocale = obj.mLocale)
Functional Scenario Form
  (obj not FastDatePrinter) && result = false or
  (obj matches all fields) && result = true or
  (any field differs) && result = false
end_process

process hashCode() result: int
pre
  true
post
  result = mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode())
Functional Scenario Form
  (always true) && result = combined hash of pattern/timezone/locale
end_process

process toString() result: String
pre
  true
post
  result = "FastDatePrinter[" + mPattern + "," + mLocale + "," + mTimeZone.getID() + "]"
Functional Scenario Form
  (always true) && result = string summary of object
end_process

process readObject(in: ObjectInputStream)
pre
  in ≠ null
post
  object state reloaded from stream ∧ init() re-executed
Functional Scenario Form
  (valid ObjectInputStream) && object fields restored and rules re-initialized
end_process

process UnpaddedNumberField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(mField) ∧ apply UnpaddedNumberField_appendTo(buffer, value)
Functional Scenario Form
  (calendar valid) && result = calendar[mField] formatted as 1-3 digits with no padding
end_process

process UnpaddedNumberField_appendTo(value: int, buffer: StringBuffer)
pre
  buffer ≠ null
post
  (value < 10) → buffer.append(single digit) &&
  (10 ≤ value < 100) → buffer.append(tens and ones digits) &&
  (value ≥ 100) → buffer.append(Integer.toString(value))
Functional Scenario Form
  (value < 10) && buffer.append(value) or
  (value ∈ [10, 99]) && buffer.append(2 digits) or
  (value ≥ 100) && buffer.append full number string
end_process

process UnpaddedMonthField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(MONTH) + 1 ∧ apply UnpaddedMonthField_appendTo(buffer, value)
Functional Scenario Form
  (calendar valid) && result = month + 1 output with no padding
end_process

process PaddedNumberField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(mField) ∧ apply PaddedNumberField_appendTo(buffer, value)
Functional Scenario Form
  (calendar valid) && buffer contains value padded to size
end_process

process PaddedNumberField_appendTo(value: int, buffer: StringBuffer)
pre
  buffer ≠ null ∧ size ≥ 3 ∧ value ≥ 0
post
  if value < 100 → pad with (size - 2) zeros then write 2 digits &&
  if value ≥ 100 → compute digit count d, pad with (size - d) zeros then write full digits
Functional Scenario Form
  (value < 100) && left-padded to size with zeros and 2-digit number or
  (value ≥ 100) && left-padded to size with zeros and full digits
end_process

process TwoDigitNumberField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(mField) ∧ apply TwoDigitNumberField_appendTo(buffer, value)
Functional Scenario Form
  (calendar valid) && buffer filled with 2-digit or full number if >99
end_process

process TwoDigitNumberField_appendTo(value: int, buffer: StringBuffer)
pre
  buffer ≠ null
post
  (value < 100) → append 2 digits &&
  (value ≥ 100) → append full string
Functional Scenario Form
  (value < 100) && buffer.append(2-digit value) or
  (value ≥ 100) && buffer.append full number string
end_process

process TwoDigitYearField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(YEAR) % 100 ∧ buffer.append(value as 2-digit)
Functional Scenario Form
  (calendar valid) && buffer contains last 2 digits of year
end_process

process TwoDigitYearField_appendTo(value: int, buffer: StringBuffer)
pre
  buffer ≠ null
post
  buffer.append(value / 10), buffer.append(value % 10)
Functional Scenario Form
  (value ∈ [0, 99]) && buffer.append(2-digit string)
end_process

process TwoDigitMonthField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(MONTH) + 1 ∧ buffer.append(two digit string of value)
Functional Scenario Form
  (calendar valid) && buffer.append(month + 1 as two-digit string)
end_process

process TwelveHourField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(HOUR) ∧
  (value = 0 → value = calendar.getLeastMaximum(HOUR) + 1) ∧
  rule.appendTo(buffer, value)
Functional Scenario Form
  (value = 0) && value ← max + 1 ∧ rule.appendTo or
  (value > 0) && rule.appendTo
end_process

process TwentyFourHourField_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  value = calendar.get(HOUR_OF_DAY) ∧
  (value = 0 → value = calendar.getMaximum(HOUR_OF_DAY) + 1) ∧
  rule.appendTo(buffer, value)
Functional Scenario Form
  (value = 0) && value ← max + 1 ∧ rule.appendTo or
  (value > 0) && rule.appendTo
end_process

process getTimeZoneDisplay(tz: TimeZone, daylight: Boolean, style: int, locale: Locale) result: sequence of char
pre
  true
post
  key = TimeZoneDisplayKey(tz, daylight, style, locale) ∧
  (key in cache → result = cached[key]) ∧
  (key not in cache → result = tz.getDisplayName(daylight, style, locale) ∧ cache updated)
Functional Scenario Form
  (key cached) && result = cache[key] or
  (key not cached) && result = getDisplayName ∧ cache.put(key, result)
end_process

process TimeZoneNameRule_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  zone = calendar.getTimeZone() ∧
  (zone.useDaylightTime() ∧ calendar.DST_OFFSET ≠ 0 → result = daylight display) ∧
  (otherwise → result = standard display) ∧
  buffer.append(result)
Functional Scenario Form
  (DST in use) && buffer.append(daylight display name) or
  (no DST) && buffer.append(standard display name)
end_process

process TimeZoneNumberRule_appendTo(calendar: Calendar, buffer: StringBuffer)
pre
  calendar ≠ null ∧ buffer ≠ null
post
  offset = ZONE_OFFSET + DST_OFFSET ∧
  sign = '+' or '-' ∧
  hours = offset / 3600000 ∧ minutes = (offset / 60000) % 60 ∧
  buffer.append formatted string as ±HH[:MM]
Functional Scenario Form
  (offset ≥ 0) && sign = '+' or
  (offset < 0) && sign = '-' ∧ value negated ∧
  (colon = true) && format = ±HH:MM or
  (colon = false) && format = ±HHMM
end_process

process TimeZoneDisplayKey_equals(obj: Object) result: Boolean
pre
  true
post
  (obj = this) → result = true &&
  (obj is TimeZoneDisplayKey ∧ all fields match) → result = true &&
  (otherwise) → result = false
Functional Scenario Form
  (obj same) && result = true or
  (obj has same tz, style, locale) && result = true or
  (otherwise) && result = false
end_process

process TimeZoneDisplayKey_hashCode() result: int
pre
  true
post
  result = (mStyle * 31 + mLocale.hashCode()) * 31 + mTimeZone.hashCode()
Functional Scenario Form
  (always true) && result = composite hash
end_process

end_module
