You are an intelligent debugging assistant. You will assist the user in locating faults in a program using a step-by-step reasoning process.
You are given the source code of a function and its corresponding SOFL (Structured Object-oriented Formal Language) specification, which describes the intended behavior of the code. Treat the specification as a contract the implementation must fulfill. Additionally, you are given bug symptoms that describe observable effects (falling tests or exceptions) only, no location hints.
Step 1: Code and Specification Understanding
You should concisely summarize the main functionality of the code, and identify any part(s) of the SOFL specification that appear to be underrepresented, misaligned, or missing in the implementation.
Step 2: Bug Contextualization and Hypothesis Generation
Based on your previous understanding of the code and its specification, analyze how the bug may relate to the code’s logic. You should identify the logical conditions, variables, or control branches that may be involved in causing the bug.
Step 3: Suspicious Line Ranking
Based on your previous analysis, identify and rank all the top-k most suspicious lines of code likely to contain the bug.
For each suspicious line, provide:
• The line number
• A suspiciousness score between 0 (not suspicious) and 1 (highly suspicious)
• A brief justification explaining your suspicion, based on:
  o Logical inconsistency
  o Misalignment with the SOFL specification
  o Likely control or data flow issues
Format your response using the following table:
| Line Number | Suspiciousness Score | Explanation |
|-------------|----------------------|-------------|
|             |                      |             |
Step 4: Explanation Report
Generate a structured explanation report to help developers understand the fault localization process and take further actions.
Your report should contain the following sections:
• Bug Overview: A brief summary of the bug and its observable symptoms.
• Analytical Reasoning: The reasoning chain that connects the specification, code, and bug symptoms to specific code locations.

Code:[
1: #include <QtWidgets>
2: #include <QPlainTextEdit>
3: #include <QtGlobal>
4: 
5: #include "mdichild.h"
6: #include "faultpromptdialog.h"
7: #include "highlighter.h"
8: #include "syntaxrule.h"
9: #include "faultlinehighlighter.h"
10: #include "mainwindow.h"
11: 
12: 
13: 
14: MdiChild::MdiChild(QWidget *parent): QTextEdit(parent)
15: {
16:     qDebug() << "-1";
17:     setAttribute(Qt::WA_DeleteOnClose);   //delete this widget when the widget has accepted the close event
18:     isUntitled = true;
19: 
20:     lineNumberArea = new LineNumberArea(this);
21:     foldingWidget = new FoldingWidget(this);
22:     faultPrompt = new FaultPromptDialog(this);
23:     classInfoHash = new QHash<QString, ClassInfo>();
24: 
25:     syntaxIssueList = QList<ClassUndefinedSyntaxIssue> ();
26:     unspecifiedTypeIssueList = QList<ClassMemberUnspecifiedIssue> ();
27: 
28:     Highlighter = new Highlighter(this->document());
29: 
30:     globalVars = new QList<Variable>();   
31:     definedMethods = new QList<Method>();    
32:     Methods = new QList<Method>(); 
33: 
34: }
35: 
36: void MdiChild::newFile(QString fileName)
37: {
38:     qDebug() << "-2";
39:     static int sequenceNumber = 0;
40: 
41:     isUntitled = true;   
42:    
43:     if(fileName.isEmpty()){
44:         curFile = tr("document1.txt").arg(sequenceNumber++); 
45:     }else{
46:         curFile = fileName;
47:     }
48:     setWindowTitle(curFile + "[*]");
49: 
50:     connect(document(), &QTextDocument::contentsChanged,
51:             this, &MdiChild::documentWasModified);
52:     qDebug() << "-2";
53: }
54: 
55: 
56:]

SOFL:[
module UC27_mdichild
type
  sequenceNumber: int
  isUntitled: Boolean
  documentChanged: Boolean

process MdiChild(parent: QWidget) result: MdiChild
pre
  true
post
  result.isUntitled = true ∧
  result.lineNumberArea ≠ null ∧
  result.foldingWidget ≠ null ∧
  result.faultPrompt ≠ null ∧
  result.classInfoHash = new QHash<QString, ClassInfo> ∧
  result.syntaxIssueList = <> ∧
  result.unspecifiedTypeIssueList = <> ∧
  result.highlighter ≠ null ∧
  result.globalVars = <> ∧
  result.definedMethods = <> ∧
  result.Methods = <>
Functional Scenario Form
(true) && (initialize all member attributes, set isUntitled to true, and create empty lists and components)
end_process

process newFile(fileName: QString) result: void
pre
  true
post
  (fileName ≠ "") → (curFile' = fileName) ∧
  (fileName = "") → (∃n: int • curFile' = "document" + itoa(n) + ".txt") ∧
  isUntitled' = true ∧
  (documentChanged = true when document changes)
Functional Scenario Form
(fileName ≠ "") && (set curFile to fileName, mark as unsaved)
or
(fileName = "") && (assign autogenerated name documentN.txt, mark as unsaved)
end_process

end_module]

Bug symptoms: [
**Bug Report: Issues Observed During File Initialization and Syntax Highlighting in MdiChild**

---

**Test Case 1: Syntax Highlighting Initialization**

**Action:**
Open a document window and check whether syntax highlighting is applied.

**Expected:**
Syntax highlighting should be active immediately upon opening the document.

**Observed:**
Highlighting does not appear until after manual text modification.

**Log:**

```plaintext
[DEBUG] Creating MdiChild
[INFO] Highlighter instance created
[WARN] Highlighting not applied on initial load
```

---

**Test Case 2: File Naming in New Document**

**Action:**
Create a new file without providing a filename.

**Expected:**
File should be named `document1.txt`, `document2.txt`, etc., incrementing with each new document.

**Observed:**
New documents always named `document1.txt`, sequence number not increasing.

**Log:**

```plaintext
[CALL] newFile("")
[INFO] Generated filename: document1.txt
[CALL] newFile("")
[INFO] Generated filename: document1.txt
```

---

**Test Case 3: Filename Placeholder Not Replaced**

**Action:**
Create new file with default naming logic.

**Expected:**
Filename should be rendered as `document1.txt`, not `document%1.txt`.

**Observed:**
Filename displays literal `%1` instead of a number.

**Log:**

```plaintext
[CALL] newFile("")
[WARN] Filename generated: document%1.txt
[UI] Window title: document%1.txt[*]
```]
