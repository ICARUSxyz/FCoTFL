bug_id,rank,file,line_number,suspiciousness,explanation,is_fault_line
1,1,BITCOUNT,15,1.0,"n = (n ^ (n - 1)); causes logical inconsistency; this expression does not reliably reduce the number of 1 bits in n, violating the SOFL postcondition count = NumberOfOnes(n). It leads to infinite loops, as confirmed by test timeouts.",1
1,2,BITCOUNT,14,0.95,"while (n != 0) depends entirely on n reaching zero. Due to faulty update logic on line 15, this loop condition becomes non-terminating for many inputs, directly causing timeouts.",0
1,3,BITCOUNT,16,0.3,"count++ increments the counter on each iteration, which is valid in structure, but becomes semantically incorrect due to flawed loop logic. It contributes to the output misalignment with the expected NumberOfOnes(n).",0
1,4,BITCOUNT,13,0.1,"int count = 0; is a necessary initialization. While not faulty itself, it's contextually relevant to the faulty increment logic.",0
1,5,BITCOUNT,18,0.05,"return count; is a passive return statement. It’s not faulty on its own, but it returns an incorrect result due to errors earlier in the control flow.",0
1,6,BITCOUNT,12,0.05,"Method signature. Not directly involved in the bug, but provides the input n, which is critical in understanding the flow.",0
1,7,BITCOUNT,1,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,8,BITCOUNT,2,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,9,BITCOUNT,3,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,10,BITCOUNT,4,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,11,BITCOUNT,5,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,12,BITCOUNT,6,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,13,BITCOUNT,7,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,14,BITCOUNT,8,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,15,BITCOUNT,9,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,16,BITCOUNT,10,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,17,BITCOUNT,11,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,18,BITCOUNT,17,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,19,BITCOUNT,19,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
1,20,BITCOUNT,20,0.0,"These are package declarations, comments, braces, and structural syntax unrelated to logic or data flow.",0
2,1,BREADTH_FIRST_SEARCH,24,1.0,"while (true) creates an infinite loop without checking if the queue is empty, directly violating the SOFL spec that requires returning false if no path exists.",1
2,2,BREADTH_FIRST_SEARCH,25,0.95,"queue.removeFirst() causes a NoSuchElementException when the queue becomes empty, proving there's no valid path and no exit condition is provided.",0
2,3,BREADTH_FIRST_SEARCH,42,0.9,"Method signature; while not buggy itself, it provides entry to the faulty logic.",1
2,4,BREADTH_FIRST_SEARCH,32,0.65,"queue.addFirst(successor_node) results in LIFO (stack-like) traversal, which violates BFS semantics expected by the spec.",0
2,5,BREADTH_FIRST_SEARCH,16,0.4,"public static Set<Node> nodesvisited = new HashSet<>(); defines a global mutable set, leading to shared state across tests and inconsistent behavior.",0
2,6,BREADTH_FIRST_SEARCH,22,0.3,"nodesvisited.add(startnode); relies on the global set; if not reset, this can skip valid paths in other invocations.",0
2,7,BREADTH_FIRST_SEARCH,28,0.1,return true; works only for the success case; its asymmetry with the missing return false amplifies the issue.,0
2,8,BREADTH_FIRST_SEARCH,38,0.05,"A comment explaining the removed return false; highlights awareness of the fault, but the absence itself is a violation.",0
2,9,BREADTH_FIRST_SEARCH,18,0.05,"Method signature; while not buggy itself, it provides entry to the faulty logic.",0
2,10,BREADTH_FIRST_SEARCH,1,0.0,Package declaration.,0
2,11,BREADTH_FIRST_SEARCH,2,0.0,Import line.,0
2,12,BREADTH_FIRST_SEARCH,3,0.0,Import line.,0
2,13,BREADTH_FIRST_SEARCH,4,0.0,Blank line.,0
2,14,BREADTH_FIRST_SEARCH,5,0.0,Start of comment block.,0
2,15,BREADTH_FIRST_SEARCH,6,0.0,Comment line.,0
2,16,BREADTH_FIRST_SEARCH,7,0.0,Comment line.,0
2,17,BREADTH_FIRST_SEARCH,8,0.0,End of comment block.,0
2,18,BREADTH_FIRST_SEARCH,9,0.0,Blank line.,0
2,19,BREADTH_FIRST_SEARCH,10,0.0,Start of Javadoc.,0
2,20,BREADTH_FIRST_SEARCH,11,0.0,Blank Javadoc line.,0
2,21,BREADTH_FIRST_SEARCH,12,0.0,Author tag.,0
2,22,BREADTH_FIRST_SEARCH,13,0.0,End of Javadoc.,0
2,23,BREADTH_FIRST_SEARCH,14,0.0,Class declaration.,0
2,24,BREADTH_FIRST_SEARCH,15,0.0,Blank line.,0
2,25,BREADTH_FIRST_SEARCH,17,0.0,Blank line.,0
2,26,BREADTH_FIRST_SEARCH,19,0.0,queue declaration.,0
2,27,BREADTH_FIRST_SEARCH,20,0.0,Adds startnode to queue â?conceptually correct.,0
2,28,BREADTH_FIRST_SEARCH,21,0.0,Blank line.,0
2,29,BREADTH_FIRST_SEARCH,23,0.0,Blank line.,0
2,30,BREADTH_FIRST_SEARCH,26,0.0,Blank line.,0
2,31,BREADTH_FIRST_SEARCH,27,0.0,if (node == goalnode) â?valid logic.,0
2,32,BREADTH_FIRST_SEARCH,29,0.0,else { â?control structure.,0
2,33,BREADTH_FIRST_SEARCH,30,0.0,Loop over successors â?expected.,0
2,34,BREADTH_FIRST_SEARCH,31,0.0,Checks for unvisited â?expected.,0
2,35,BREADTH_FIRST_SEARCH,33,0.0,Marks successor as visited â?valid.,0
2,36,BREADTH_FIRST_SEARCH,34,0.0,Closes if block.,0
2,37,BREADTH_FIRST_SEARCH,35,0.0,Closes for block.,0
2,38,BREADTH_FIRST_SEARCH,36,0.0,Closes else block.,0
2,39,BREADTH_FIRST_SEARCH,37,0.0,Closes while block.,0
2,40,BREADTH_FIRST_SEARCH,39,0.0,Closes method.,0
2,41,BREADTH_FIRST_SEARCH,40,0.0,Blank,0
2,42,BREADTH_FIRST_SEARCH,41,0.0,Blank,0
2,43,BREADTH_FIRST_SEARCH,43,0.0,Blank,0
2,44,BREADTH_FIRST_SEARCH,44,0.0,Blank,0
2,45,BREADTH_FIRST_SEARCH,45,0.0,Blank,0
3,1,BUCKETSORT,22,1.0,"for (Integer count : arr) mistakenly iterates over arr instead of counts, invalidating the reconstruction logic and violating the SOFL postcondition.",1
3,2,BUCKETSORT,23,0.95,"sorted_arr.addAll(Collections.nCopies(count, i)) uses incorrect count values derived from arr, producing outputs with excessive or invalid data.",0
3,3,BUCKETSORT,10,0.6,"counts is correctly constructed but never used in reconstruction, indicating a logic disconnection.",0
3,4,BUCKETSORT,26,0.45,return sorted_arr; outputs a list that fails both parts of the SOFL postcondition (sorted content and permutation of original input).,0
3,5,BUCKETSORT,24,0.4,"i++ is incremented with the assumption of correct iteration, which is invalid here.",0
3,6,BUCKETSORT,21,0.2,"Initializes i = 0, harmless alone but its role becomes problematic due to misuse in later lines.",0
3,7,BUCKETSORT,12,0.1,"sorted_arr is preallocated with size 100, which is not harmful but unnecessary and can be misleading in practice.",0
3,8,BUCKETSORT,9,0.05,Method signature is not itself faulty but is the entry point into a flawed process.,0
3,9,BUCKETSORT,1,0.0,Package declaration.,0
3,10,BUCKETSORT,2,0.0,Standard library import.,0
3,11,BUCKETSORT,3,0.0,"Redundant import, not involved in logic.",0
3,12,BUCKETSORT,4,0.0,Blank line.,0
3,13,BUCKETSORT,5,0.0,Start of comment block.,0
3,14,BUCKETSORT,6,0.0,Comment line.,0
3,15,BUCKETSORT,7,0.0,Comment line.,0
3,16,BUCKETSORT,8,0.0,End of comment block.,0
3,17,BUCKETSORT,11,0.0,for (Integer x : arr) is correct and implements counting phase properly.,0
3,18,BUCKETSORT,13,0.0,"counts.set(x, counts.get(x)+1) is correct for frequency counting.",0
3,19,BUCKETSORT,14,0.0,Closes counting loop — no issue.,0
3,20,BUCKETSORT,15,0.0,Blank line.,0
3,21,BUCKETSORT,16,0.0,Declares sorted_arr — valid step.,0
3,22,BUCKETSORT,17,0.0,Blank line.,0
3,23,BUCKETSORT,18,0.0,Another blank line.,0
3,24,BUCKETSORT,19,0.0,Opening brace for loop.,0
3,25,BUCKETSORT,20,0.0,Blank line.,0
3,26,BUCKETSORT,25,0.0,Closes reconstruction loop — structurally fine.,0
3,27,BUCKETSORT,27,0.0,Closes method.,0
3,28,BUCKETSORT,28,0.0,Closes class.,0
3,29,BUCKETSORT,29,0.0,End of file (implicit).,0
4,1,DEPTH_FIRST_SEARCH,17,1.0,"if (nodesvisited.contains(node)) is meant to prevent revisits, but since nodesvisited.add(node) is missing, it always returns false, breaking DFS correctness.",0
4,2,DEPTH_FIRST_SEARCH,22,0.4,Loop over successors is structurally correct but becomes dangerous without proper visited-node tracking.,1
4,3,DEPTH_FIRST_SEARCH,14,0.95,"nodesvisited is declared but never updated; it remains empty throughout recursion, enabling infinite revisits.",0
4,4,DEPTH_FIRST_SEARCH,23,0.8,"Recursive call search(successornodes) re-enters the same nodes in cycles without protection, leading to stack overflow.",0
4,5,DEPTH_FIRST_SEARCH,16,0.2,"Start of the recursive logic. The core traversal is nested here, so the context matters even though the signature is correct.",0
4,6,DEPTH_FIRST_SEARCH,31,0.1,The initial call s.search(startnode) triggers the recursive process; safe structurally but leads into faulty logic.,0
4,7,DEPTH_FIRST_SEARCH,13,0.05,Method header is correct but leads into the faulty implementation.,0
4,8,DEPTH_FIRST_SEARCH,19,0.0,if (node == goalnode) correctly checks for base case success.,0
4,9,DEPTH_FIRST_SEARCH,20,0.0,return true on goal found is logically sound.,0
4,10,DEPTH_FIRST_SEARCH,18,0.0,"Returns false if visited, which would be valid if nodesvisited were correctly updated.",0
4,11,DEPTH_FIRST_SEARCH,26,0.0,Final return in recursive call when no match found; not faulty.,0
4,12,DEPTH_FIRST_SEARCH,1,0.0,Package declaration.,0
4,13,DEPTH_FIRST_SEARCH,2,0.0,Library imports.,0
4,14,DEPTH_FIRST_SEARCH,3,0.0,Start of comment block.,0
4,15,DEPTH_FIRST_SEARCH,4,0.0,Comment line.,0
4,16,DEPTH_FIRST_SEARCH,5,0.0,Comment line.,0
4,17,DEPTH_FIRST_SEARCH,6,0.0,End of comment block.,0
4,18,DEPTH_FIRST_SEARCH,7,0.0,Blank line.,0
4,19,DEPTH_FIRST_SEARCH,8,0.0,Javadoc start.,0
4,20,DEPTH_FIRST_SEARCH,9,0.0,Javadoc spacing.,0
4,21,DEPTH_FIRST_SEARCH,10,0.0,Author tag.,0
4,22,DEPTH_FIRST_SEARCH,11,0.0,Javadoc end.,0
4,23,DEPTH_FIRST_SEARCH,12,0.0,Class declaration.,0
4,24,DEPTH_FIRST_SEARCH,15,0.0,Inner class declaration.,0
4,25,DEPTH_FIRST_SEARCH,21,0.0,Opening brace for successor loop.,0
4,26,DEPTH_FIRST_SEARCH,24,0.0,Closing brace of successor loop.,0
4,27,DEPTH_FIRST_SEARCH,25,0.0,Closing brace of else block.,0
4,28,DEPTH_FIRST_SEARCH,27,0.0,Closing brace of search method.,0
4,29,DEPTH_FIRST_SEARCH,28,0.0,Closing brace of inner class.,0
4,30,DEPTH_FIRST_SEARCH,29,0.0,Blank line.,0
4,31,DEPTH_FIRST_SEARCH,30,0.0,Search s = new Search(); â?instantiates the inner class correctly.,0
4,32,DEPTH_FIRST_SEARCH,32,0.0,Closing brace of depth_first_search.,0
4,33,DEPTH_FIRST_SEARCH,33,0.0,Blank line.,0
4,34,DEPTH_FIRST_SEARCH,34,0.0,Closing brace of outer class.,0
5,1,DETECT_CYCLE,22,1.0,hare = hare.getSuccessor().getSuccessor(); causes NullPointerException when hare.getSuccessor() is null. No safety check is in place.,0
5,2,DETECT_CYCLE,18,0.85,"if (hare.getSuccessor() == null) partially guards traversal, but does not check if hare.getSuccessor().getSuccessor() is null, making it ineffective.",1
5,3,DETECT_CYCLE,13,0.5,"public static boolean detect_cycle(Node node) lacks a node != null input check, violating the SOFL precondition and risking a crash if input is null.",0
5,4,DETECT_CYCLE,14,0.2,Node hare = node; assigns node without null check; will throw if input is invalid.,0
5,5,DETECT_CYCLE,15,0.1,"Similar to line 14, tortoise = node; replicates the risk if node is null.",0
5,6,DETECT_CYCLE,17,0.05,"Beginning of while loop — safe on its own, but contextually involved in unsafe traversal.",0
5,7,DETECT_CYCLE,19,0.0,return false; — logic is valid if a safe null check precedes it.,0
5,8,DETECT_CYCLE,21,0.0,tortoise = tortoise.getSuccessor(); is safe as long as hare checks are fixed.,0
5,9,DETECT_CYCLE,24,0.0,Checks if hare meets tortoise — correct cycle detection logic.,0
5,10,DETECT_CYCLE,25,0.0,return true; is logically sound.,0
5,11,DETECT_CYCLE,26,0.0,Loop continues — no issue with syntax.,0
5,12,DETECT_CYCLE,1,0.0,Package declaration.,0
5,13,DETECT_CYCLE,2,0.0,Import statement.,0
5,14,DETECT_CYCLE,3,0.0,Comment block — non-functional.,0
5,15,DETECT_CYCLE,4,0.0,Blank line.,0
5,16,DETECT_CYCLE,5,0.0,Blank line.,0
5,17,DETECT_CYCLE,6,0.0,Blank line.,0
5,18,DETECT_CYCLE,7,0.0,Blank line.,0
5,19,DETECT_CYCLE,8,0.0,Blank line.,0
5,20,DETECT_CYCLE,9,0.0,Blank line.,0
5,21,DETECT_CYCLE,10,0.0,Blank line.,0
5,22,DETECT_CYCLE,11,0.0,Javadoc and metadata.,0
5,23,DETECT_CYCLE,12,0.0,Class declaration.,0
5,24,DETECT_CYCLE,16,0.0,Blank line.,0
5,25,DETECT_CYCLE,20,0.0,Blank line.,0
5,26,DETECT_CYCLE,23,0.0,Blank line.,0
5,27,DETECT_CYCLE,27,0.0,Closing brace of method.,0
5,28,DETECT_CYCLE,28,0.0,Closing brace of class.,0
6,1,FIND_FIRST_IN_SORTED,19,1.0,"while (lo <= hi) runs with hi = arr.length, causing a non-terminating loop or invalid access when lo and hi don't converge.",1
6,2,FIND_FIRST_IN_SORTED,17,0.95,"int hi = arr.length; sets hi out of bounds for Java arrays (should be arr.length - 1), enabling mid = arr.length, causing arr[mid] to throw.",0
6,3,FIND_FIRST_IN_SORTED,22,0.95,"arr[mid] accessed directly; if mid == arr.length, this line throws ArrayIndexOutOfBoundsException.",0
6,4,FIND_FIRST_IN_SORTED,24,0.6,"hi = mid; without subtracting 1 risks an infinite loop (e.g., when mid == hi). It should likely be hi = mid - 1.",0
6,5,FIND_FIRST_IN_SORTED,15,0.4,"Function signature lacks input validation (e.g., arr == null, arr.length == 0), which could lead to silent failure or misleading results.",0
6,6,FIND_FIRST_IN_SORTED,20,0.3,"int mid = (lo + hi) / 2; â?safe in isolation, but with improper hi, it becomes dangerous. Should be lo + (hi - lo) / 2 for safer bounds.",0
6,7,FIND_FIRST_IN_SORTED,31,0.05,"return -1; â?logically fine, but used too late in cases where input is invalid or loop is broken.",0
6,8,FIND_FIRST_IN_SORTED,1,0.0,Package declaration.,0
6,9,FIND_FIRST_IN_SORTED,2,0.0,Library import.,0
6,10,FIND_FIRST_IN_SORTED,3,0.0,IDE-generated comment block.,0
6,11,FIND_FIRST_IN_SORTED,4,0.0,Blank line.,0
6,12,FIND_FIRST_IN_SORTED,5,0.0,Javadoc metadata.,0
6,13,FIND_FIRST_IN_SORTED,6,0.0,Class header.,0
6,14,FIND_FIRST_IN_SORTED,7,0.0,Blank line.,0
6,15,FIND_FIRST_IN_SORTED,8,0.0,Javadoc metadata.,0
6,16,FIND_FIRST_IN_SORTED,9,0.0,Class header.,0
6,17,FIND_FIRST_IN_SORTED,10,0.0,Blank line.,0
6,18,FIND_FIRST_IN_SORTED,11,0.0,Blank line.,0
6,19,FIND_FIRST_IN_SORTED,12,0.0,Class header.,0
6,20,FIND_FIRST_IN_SORTED,13,0.0,Blank line.,0
6,21,FIND_FIRST_IN_SORTED,14,0.0,Start of method.,0
6,22,FIND_FIRST_IN_SORTED,16,0.0,int lo = 0; â?standard lower bound.,0
6,23,FIND_FIRST_IN_SORTED,18,0.0,Blank line.,0
6,24,FIND_FIRST_IN_SORTED,21,0.0,Blank line.,0
6,25,FIND_FIRST_IN_SORTED,23,0.0,Correct return if match is found at correct position.,0
6,26,FIND_FIRST_IN_SORTED,25,0.0,else { â?control block.,0
6,27,FIND_FIRST_IN_SORTED,26,0.0,lo = mid + 1; â?standard binary search logic.,0
6,28,FIND_FIRST_IN_SORTED,27,0.0,Closing brace.,0
6,29,FIND_FIRST_IN_SORTED,28,0.0,Final return and class/method closing braces.,0
6,30,FIND_FIRST_IN_SORTED,29,0.0,Closing brace.,0
6,31,FIND_FIRST_IN_SORTED,30,0.0,Final return and class/method closing braces.,0
6,32,FIND_FIRST_IN_SORTED,31,0.0,Closing brace.,0
6,33,FIND_FIRST_IN_SORTED,32,0.0,Final return and class/method closing braces.,0
6,34,FIND_FIRST_IN_SORTED,33,0.0,Closing brace.,0
6,35,FIND_FIRST_IN_SORTED,34,0.0,Final return and class/method closing braces.,0
7,1,FIND_IN_SORTED,20,1.0,"Recursive call on binsearch(arr, x, mid, end) may repeat endlessly if mid == start or mid == end.",1
7,2,FIND_IN_SORTED,27,1.0,"Passes end = arr.length into binsearch, enabling out-of-bounds mid computation.",0
7,3,FIND_IN_SORTED,18,0.9,Similar to line 20; may cause non-progressing recursion when start == mid.,0
7,4,FIND_IN_SORTED,16,0.8,"Midpoint calculation can result in mid == arr.length, causing arr[mid] to throw if not properly guarded.",0
7,5,FIND_IN_SORTED,22,0.75,Accesses arr[mid] without checking if mid is within bounds; directly causes crash in test_1.,0
7,6,FIND_IN_SORTED,13,0.4,Base case if (start == end) is too weak to prevent infinite recursion when range does not shrink.,0
7,7,FIND_IN_SORTED,26,0.3,"Main method delegates to faulty binsearch, contributing indirectly to bug via unbounded end.",0
7,8,FIND_IN_SORTED,12,0.2,Declaration of binsearch; flawed design in parameter contract allows invalid bounds.,0
7,9,FIND_IN_SORTED,15,0.1,Function body start â?not faulty itself but involved in control flow.,0
7,10,FIND_IN_SORTED,14,0.05,return -1; â?safe but may be reached too late due to faulty termination logic.,0
7,11,FIND_IN_SORTED,19,0.05,"Structural condition, branching correctly â?low direct fault impact.",0
7,12,FIND_IN_SORTED,17,0.05,Start of branching â?not inherently faulty.,0
7,13,FIND_IN_SORTED,21,0.05,else clause â?logic is sound.,0
7,14,FIND_IN_SORTED,23,0.0,return mid; is correct if reached safely.,0
7,15,FIND_IN_SORTED,24,0.0,Method close.,0
7,16,FIND_IN_SORTED,25,0.0,Blank line.,0
7,17,FIND_IN_SORTED,28,0.0,Blank line.,0
7,18,FIND_IN_SORTED,29,0.0,Class closing brace.,0
7,19,FIND_IN_SORTED,1,0.0,Package declaration.,0
7,20,FIND_IN_SORTED,2,0.0,Start of comment block.,0
7,21,FIND_IN_SORTED,3,0.0,IDE template comment.,0
7,22,FIND_IN_SORTED,4,0.0,IDE template comment.,0
7,23,FIND_IN_SORTED,5,0.0,End of comment block.,0
7,24,FIND_IN_SORTED,6,0.0,Blank line.,0
7,25,FIND_IN_SORTED,7,0.0,Javadoc start.,0
7,26,FIND_IN_SORTED,8,0.0,Javadoc author tag.,0
7,27,FIND_IN_SORTED,9,0.0,Author name.,0
7,28,FIND_IN_SORTED,10,0.0,Javadoc end.,0
7,29,FIND_IN_SORTED,11,0.0,Class declaration.,0
8,1,FLATTEN,26,1.0,Infinite recursive call on arr itself without checking for a base case; directly causes StackOverflowError when arr is not an ArrayList.,1
8,2,FLATTEN,21,0.95,"Calls flatten(x) without verifying that x is not an ArrayList, which will route to line 26 and recurse infinitely for scalar values.",1
8,3,FLATTEN,14,0.6,"Controls whether the input is treated as a list; does not ensure that the non-list path (i.e., scalar input) is properly handled.",0
8,4,FLATTEN,13,0.3,"Entry point of the function; although correct in definition, it accepts Object inputs without sufficient type guard logic, violating SOFL's ""true"" precondition.",0
8,5,FLATTEN,15,0.1,"Casts to ArrayList under the assumption that arr is a list, which is safe due to the instanceof check, but still contributes indirectly to logic flow.",0
8,6,FLATTEN,16,0.05,"Initializes the result list, logically sound, but downstream logic depends on proper recursion control.",0
8,7,FLATTEN,12,0.0,Method signature; not directly related to the recursion fault.,0
8,8,FLATTEN,17,0.0,For-loop iteration setup; no observed issue with structure.,0
8,9,FLATTEN,18,0.0,Recursion on nested lists; logic appears consistent with intent.,0
8,10,FLATTEN,19,0.0,Correctly flattens nested lists using addAll.,0
8,11,FLATTEN,20,0.0,Control path for scalar elements; problem lies in next call.,0
8,12,FLATTEN,22,0.0,Correctly adds flattened result to list.,0
8,13,FLATTEN,23,0.0,End of for-loop block; not relevant to bug.,0
8,14,FLATTEN,24,0.0,Returns result list from list case; working correctly.,0
8,15,FLATTEN,25,0.0,"else block opener; structurally fine, logic issue is in 26.",0
8,16,FLATTEN,27,0.0,End of method.,0
8,17,FLATTEN,28,0.0,End of class.,0
8,18,FLATTEN,1,0.0,Blank,0
8,19,FLATTEN,2,0.0,Blank,0
8,20,FLATTEN,3,0.0,Blank,0
8,21,FLATTEN,4,0.0,Blank,0
8,22,FLATTEN,5,0.0,Blank,0
8,23,FLATTEN,6,0.0,Blank,0
8,24,FLATTEN,7,0.0,Blank,0
8,25,FLATTEN,8,0.0,Blank,0
8,26,FLATTEN,9,0.0,Blank,0
8,27,FLATTEN,10,0.0,Blank,0
8,28,FLATTEN,11,0.0,Blank,0
8,29,FLATTEN,29,0.0,Blank,0
9,1,GCD,19,1.0,"Calls gcd(a % b, b) instead of standard gcd(b, a % b), causing infinite recursion when a < b.",1
9,2,GCD,15,0.6,Entry point to the recursive method; lacks input validation for a ≥ 0 ∧ b ≥ 0 ∧ (a ≠ 0 ∨ b ≠ 0) as required by SOFL precondition.,0
9,3,GCD,16,0.1,"Base case if (b == 0) is logically sound, but does not validate a > 0, which could violate SOFL spec if a = 0.",0
9,4,GCD,20,0.0,"else block itself is structurally fine, but continues the flawed logic initiated at line 19.",0
9,5,GCD,17,0.0,"Return of a in base case is correct when b == 0, assuming valid inputs.",0
9,6,GCD,18,0.0,"Part of standard recursion block, no independent logical fault.",0
9,7,GCD,21,0.0,"Structural end of method, not relevant to logic.",0
9,8,GCD,22,0.0,Class closing bracket; no functional logic.,0
9,9,GCD,14,0.0,Method header itself is fine in terms of signature.,0
9,10,GCD,13,0.0,Class declaration — no issues.,0
9,11,GCD,1,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,12,GCD,2,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,13,GCD,3,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,14,GCD,4,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,15,GCD,5,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,16,GCD,6,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,17,GCD,7,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,18,GCD,8,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,19,GCD,9,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,20,GCD,10,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,21,GCD,11,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
9,22,GCD,12,0.0,Package/imports/comments/JavaDoc — do not affect logic.,0
10,1,GET_FACTORS,27,1.0,Always returns empty list if no factor found; violates postcondition that prime n should be returned as singleton list [n].,1
10,2,GET_FACTORS,14,0.9,No base case for returning n when n is prime; leads to incorrect results and empty list.,0
10,3,GET_FACTORS,23,0.8,"Recursively builds the factor list, but fails to handle the case when n / i is a prime number that should be included.",0
10,4,GET_FACTORS,22,0.3,"Adds a divisor i, but only works correctly when n % i == 0; contributes to incomplete result when n is prime.",0
10,5,GET_FACTORS,19,0.2,"Iteration may miss larger prime divisors due to loop bounds; however, logic is otherwise sound.",0
10,6,GET_FACTORS,18,0.1,Uses approximate bound for loop (sqrt(n) + 1.0); may skip a factor equal to n itself.,0
10,7,GET_FACTORS,15,0.05,"Valid check for base case n == 1, though complements precondition; harmless.",0
10,8,GET_FACTORS,24,0.05,Early return on successful factor division; logic is sound but contributes to overall control flow that fails on prime n.,0
10,9,GET_FACTORS,21,0.01,Initializes new result list; minor role in logic.,0
10,10,GET_FACTORS,20,0.01,Correct conditional logic; low suspicion.,0
10,11,GET_FACTORS,25,0.01,Proper control flow continuation.,0
10,12,GET_FACTORS,16,0.01,Returns empty list for n == 1; correct per specification.,0
10,13,GET_FACTORS,26,0.01,Ends loop scope; structurally fine.,0
10,14,GET_FACTORS,17,0.0,Empty line; not executable.,0
10,15,GET_FACTORS,28,0.0,Closes method; no logic here.,0
10,16,GET_FACTORS,29,0.0,Closes class; not related to logic.,0
10,17,GET_FACTORS,13,0.0,Class declaration.,0
10,18,GET_FACTORS,12,0.0,Comment block closure.,0
10,19,GET_FACTORS,11,0.0,Javadoc author tag.,0
10,20,GET_FACTORS,10,0.0,Empty Javadoc line.,0
10,21,GET_FACTORS,9,0.0,Javadoc start.,0
10,22,GET_FACTORS,8,0.0,Empty line.,0
10,23,GET_FACTORS,7,0.0,Comment block end.,0
10,24,GET_FACTORS,6,0.0,Comment on IDE.,0
10,25,GET_FACTORS,5,0.0,Comment on IDE.,0
10,26,GET_FACTORS,4,0.0,Start of IDE comment block.,0
10,27,GET_FACTORS,3,0.0,Empty line.,0
10,28,GET_FACTORS,2,0.0,Import statement.,0
10,29,GET_FACTORS,1,0.0,Package declaration.,0
11,1,HANOI,27,1.0,Adds a move between start and end; incorrect helper may result in illegal or logically invalid move.,1
11,2,HANOI,25,0.98,"Helper peg is selected using poll() from a PriorityQueue, which does not guarantee deterministic order after removal, leading to incorrect move sequences.",0
11,3,HANOI,23,0.95,"Removes start from PriorityQueue; due to unordered structure, may not remove intended peg.",0
11,4,HANOI,24,0.95,"Removes end from PriorityQueue; same issue as above, corrupting helper peg computation.",0
11,5,HANOI,19,0.9,Uses PriorityQueue for crap_set where order matters; this violates logical assumptions about peg selection.,0
11,6,HANOI,15,0.7,Entry point lacks precondition check start â?end; violates SOFL specification when start == end.,0
11,7,HANOI,26,0.65,"Recursive call may propagate incorrect helper, leading to invalid moves.",0
11,8,HANOI,28,0.65,"Same as above â?recursion may use wrong helper, disrupting peg logic.",0
11,9,HANOI,18,0.3,"Entry to recursive branch; functionally correct, but allows logic underneath to propagate errors.",0
11,10,HANOI,31,0.1,"Returns the sequence of moves; if previous steps are incorrect, the output will be invalid but this line itself is structurally sound.",0
11,11,HANOI,16,0.05,"Initializes result list; not buggy, but stores potentially invalid data.",0
11,12,HANOI,32,0.01,End of hanoi() method; not involved in logic.,0
11,13,HANOI,14,0.01,Comment line describing parameter defaults; no executable logic.,0
11,14,HANOI,13,0.0,Class declaration for HANOI.,0
11,15,HANOI,12,0.0,End of comment block.,0
11,16,HANOI,11,0.0,Author tag.,0
11,17,HANOI,10,0.0,Comment.,0
11,18,HANOI,9,0.0,Start of Javadoc comment.,0
11,19,HANOI,8,0.0,Blank line.,0
11,20,HANOI,7,0.0,Comment.,0
11,21,HANOI,6,0.0,Comment.,0
11,22,HANOI,5,0.0,Comment.,0
11,23,HANOI,4,0.0,Start of block comment.,0
11,24,HANOI,3,0.0,Import line.,0
11,25,HANOI,2,0.0,Import line.,0
11,26,HANOI,1,0.0,Package declaration.,0
11,27,HANOI,35,0.0,Inner class Pair declaration.,0
11,28,HANOI,36,0.0,Field first; unrelated to control/data logic.,0
11,29,HANOI,37,0.0,Field second; same as above.,0
11,30,HANOI,38,0.0,Blank line.,0
11,31,HANOI,39,0.0,Constructor for Pair.,0
11,32,HANOI,40,0.0,Sets first; correct usage.,0
11,33,HANOI,41,0.0,Sets second; same.,0
11,34,HANOI,42,0.0,Constructor end.,0
11,35,HANOI,43,0.0,Blank line.,0
11,36,HANOI,44,0.0,Setter for first.,0
11,37,HANOI,45,0.0,Assignment; not faulty.,0
11,38,HANOI,46,0.0,End setter.,0
11,39,HANOI,47,0.0,Blank line.,0
11,40,HANOI,48,0.0,Setter for second.,0
11,41,HANOI,49,0.0,Assignment.,0
11,42,HANOI,50,0.0,End setter.,0
11,43,HANOI,51,0.0,Blank line.,0
11,44,HANOI,52,0.0,Getter for first.,0
11,45,HANOI,53,0.0,Returns first.,0
11,46,HANOI,54,0.0,End getter.,0
11,47,HANOI,55,0.0,Blank line.,0
11,48,HANOI,56,0.0,Getter for second.,0
11,49,HANOI,57,0.0,Returns second.,0
11,50,HANOI,58,0.0,End getter.,0
11,51,HANOI,59,0.0,Blank line.,0
11,52,HANOI,60,0.0,toString() override.,0
11,53,HANOI,61,0.0,Builds string.,0
11,54,HANOI,62,0.0,Returns formatted result.,0
11,55,HANOI,63,0.0,End of override.,0
11,56,HANOI,64,0.0,End of inner class.,0
11,57,HANOI,65,0.0,End of outer class.,0
11,58,HANOI,17,0.0,Blank,0
11,59,HANOI,20,0.0,Blank,0
11,60,HANOI,21,0.0,Blank,0
11,61,HANOI,22,0.0,Blank,0
11,62,HANOI,29,0.0,Blank,0
11,63,HANOI,30,0.0,Blank,0
11,64,HANOI,33,0.0,Blank,0
11,65,HANOI,34,0.0,Blank,0
12,1,IS_VALID_PARENTHESIZATION,24,1.0,"Unconditionally returns true without verifying that all opened parentheses have been closed (depth == 0), violating the postcondition.",1
12,2,IS_VALID_PARENTHESIZATION,14,0.8,"Initializes the depth variable correctly, but its final state is never validated, contributing to the missing correctness check.",0
12,3,IS_VALID_PARENTHESIZATION,21,0.4,"Handles over-closing (depth < 0), but highlights the asymmetry — under-closing (leftover () is ignored entirely.",0
12,4,IS_VALID_PARENTHESIZATION,13,0.3,Method signature — the correctness of this method directly depends on properly validating well-formed parentheses.,0
12,5,IS_VALID_PARENTHESIZATION,23,0.1,Closes the loop — no action is taken to validate the final value of depth.,0
12,6,IS_VALID_PARENTHESIZATION,15,0.05,"For loop bounds are standard, but contributes to overall logic that doesn’t validate final depth.",0
12,7,IS_VALID_PARENTHESIZATION,16,0.05,"Extracts character from the string — relevant to control flow, but implementation here is fine.",0
12,8,IS_VALID_PARENTHESIZATION,17,0.01,Correctly checks for '(' character.,0
12,9,IS_VALID_PARENTHESIZATION,18,0.01,"Increments depth, consistent with parentheses tracking logic.",0
12,10,IS_VALID_PARENTHESIZATION,19,0.01,Else block correctly assumes ')' if not '('.,0
12,11,IS_VALID_PARENTHESIZATION,20,0.01,Decrements depth for closing parentheses.,0
12,12,IS_VALID_PARENTHESIZATION,22,0.01,Correctly returns false if closing parentheses appear without matching opening ones.,0
12,13,IS_VALID_PARENTHESIZATION,25,0.0,Method closing — no effect on logic.,0
12,14,IS_VALID_PARENTHESIZATION,12,0.0,Class declaration — not involved in control logic.,0
12,15,IS_VALID_PARENTHESIZATION,1,0.0,Package declaration.,0
12,16,IS_VALID_PARENTHESIZATION,2,0.0,Imports.,0
12,17,IS_VALID_PARENTHESIZATION,3,0.0,Comment line — no semantic value.,0
12,18,IS_VALID_PARENTHESIZATION,4,0.0,Comment line.,0
12,19,IS_VALID_PARENTHESIZATION,5,0.0,Comment line.,0
12,20,IS_VALID_PARENTHESIZATION,6,0.0,Comment line.,0
12,21,IS_VALID_PARENTHESIZATION,7,0.0,Blank line.,0
12,22,IS_VALID_PARENTHESIZATION,8,0.0,Javadoc comment start.,0
12,23,IS_VALID_PARENTHESIZATION,9,0.0,Javadoc comment.,0
12,24,IS_VALID_PARENTHESIZATION,10,0.0,Javadoc comment.,0
12,25,IS_VALID_PARENTHESIZATION,11,0.0,Javadoc comment.,0
12,26,IS_VALID_PARENTHESIZATION,26,0.0,Blank,0
13,1,KHEAPSORT,27,1.0,Looping over all arr elements causes duplicated insertions into the heap.,1
13,2,KHEAPSORT,28,1.0,"Re-adding all elements to the heap introduces duplicates, violating sorting and permutation properties.",0
13,3,KHEAPSORT,29,0.9,Polling from a wrongly populated heap leads to incorrect or repeated output.,0
13,4,KHEAPSORT,30,0.9,Adding incorrect elements into output because heap content is wrong.,0
13,5,KHEAPSORT,22,0.7,"Initial heap setup with arr.subList(0, k) is correct but unprotected, enabling duplication later.",0
13,6,KHEAPSORT,21,0.5,Heap initialization itself is standard but indirectly allows wrong behavior by misuse later.,0
13,7,KHEAPSORT,33,0.4,"Drains all elements from an incorrectly built heap, worsening the final output problem.",0
13,8,KHEAPSORT,34,0.4,Adds elements remaining in a wrong heap to output.,0
13,9,KHEAPSORT,20,0.2,Function declaration line; involved but not directly causing faulty logic.,0
13,10,KHEAPSORT,26,0.2,Output list initialization; output accumulates bad elements but this line itself is standard.,0
13,11,KHEAPSORT,31,0.1,"End of if (height > 0) block; correctly structured, no logical flaw here.",0
13,12,KHEAPSORT,32,0.1,Correctly returns output; the return itself is not faulty.,0
13,13,KHEAPSORT,37,0.1,Method returns output; returning happens after faulty population.,0
13,14,KHEAPSORT,39,0.0,"Empty line, no logic.",0
13,15,KHEAPSORT,18,0.0,"Comment about binary tree heap properties, not executable.",0
13,16,KHEAPSORT,19,0.0,"Comment about priority queue ordering, not executable.",0
13,17,KHEAPSORT,17,0.0,"Comment about heap node structure, not executable.",0
13,18,KHEAPSORT,16,0.0,"Comment about binary tree heap concept, not executable.",0
13,19,KHEAPSORT,15,0.0,"Comment about heap O(log n) property, not executable.",0
13,20,KHEAPSORT,14,0.0,"Comment about heap import, not executable.",0
13,21,KHEAPSORT,13,0.0,"Class declaration KHEAPSORT, no issues.",0
13,22,KHEAPSORT,12,0.0,"Class definition line, no issues.",0
13,23,KHEAPSORT,11,0.0,"JavaDoc author tag, non-code.",0
13,24,KHEAPSORT,10,0.0,"JavaDoc blank line, non-code.",0
13,25,KHEAPSORT,9,0.0,"JavaDoc start, non-code.",0
13,26,KHEAPSORT,8,0.0,"Blank line, no logic.",0
13,27,KHEAPSORT,7,0.0,"End of comment block, no code.",0
13,28,KHEAPSORT,6,0.0,"Comment line for IDE templates, no code.",0
13,29,KHEAPSORT,5,0.0,"Comment line for IDE templates, no code.",0
13,30,KHEAPSORT,4,0.0,"Comment line for IDE templates, no code.",0
13,31,KHEAPSORT,3,0.0,"Comment line for IDE templates, no code.",0
13,32,KHEAPSORT,2,0.0,"Import java.util.*, normal import.",0
13,33,KHEAPSORT,1,0.0,"Package declaration, standard.",0
13,34,KHEAPSORT,23,0.0,Blank,0
13,35,KHEAPSORT,24,0.0,Blank,0
13,36,KHEAPSORT,25,0.0,Blank,0
13,37,KHEAPSORT,35,0.0,Blank,0
13,38,KHEAPSORT,36,0.0,Blank,0
13,39,KHEAPSORT,38,0.0,Blank,0
13,40,KHEAPSORT,40,0.0,Blank,0
14,1,KNAPSACK,30,1.0,"The condition weight < j wrongly excludes cases where weight == j, leading to failure to include valid items when weight exactly matches capacity.",1
14,2,KNAPSACK,31,0.9,"The memoization logic depends directly on the previous wrong condition, so the wrong subset value is calculated.",0
14,3,KNAPSACK,25,0.6,"Loop iterates over j, but correctness depends critically on the condition inside; indirectly related to faulty updates.",0
14,4,KNAPSACK,29,0.5,Redundant initialization of memo[i][j] = 0 is correct but related to the control flow of memo filling. Slight suspicion as an adjacent part.,0
14,5,KNAPSACK,19,0.4,"Loop over i is generally sound, but memoization depends on the correct sequencing of i and j; minor relevance.",0
14,6,KNAPSACK,21,0.3,"Item attribute assignment is done with i-1 indexing. While generally safe, wrong item assignment would propagate, but less suspicious.",0
14,7,KNAPSACK,22,0.3,"Assignment of weight from items[i-1][0] is safe assuming correct structure, low suspicion.",0
14,8,KNAPSACK,23,0.3,"Assignment of value from items[i-1][1], similarly minor.",0
14,9,KNAPSACK,14,0.2,Method signature; only suspicious if input handling is wrong (not the case here).,0
14,10,KNAPSACK,15,0.2,Initialization of weight and value; unlikely to cause the fault unless misused later.,0
14,11,KNAPSACK,16,0.2,Computation of n = items.length is correct but basic; very low suspicion.,0
14,12,KNAPSACK,17,0.2,Initialization of memoization table; no apparent error in size.,0
14,13,KNAPSACK,20,0.1,Start of for loop; structure is standard.,0
14,14,KNAPSACK,24,0.1,End of conditional block setting weight and value; no clear problem.,0
14,15,KNAPSACK,26,0.1,Start of inner loop; structure is fine.,0
14,16,KNAPSACK,27,0.1,Checking `i==0,0
14,17,KNAPSACK,28,0.1,Setting memo[i][j]=0 in base cases; normal initialization.,0
14,18,KNAPSACK,32,0.1,"else branch when weight >= j, slightly irrelevant to the specific fault.",0
14,19,KNAPSACK,33,0.1,"Setting memo[i][j]=memo[i-1][j], standard no-pick condition.",0
14,20,KNAPSACK,34,0.1,Closing else block; no issues.,0
14,21,KNAPSACK,37,0.0,End of inner loop. Pure control flow.,0
14,22,KNAPSACK,38,0.0,End of outer loop. Pure control flow.,0
14,23,KNAPSACK,39,0.0,Return statement; not suspicious.,0
14,24,KNAPSACK,40,0.0,End of method. No issue.,0
14,25,KNAPSACK,41,0.0,End of class. Pure syntax.,0
14,26,KNAPSACK,1,0.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,27,KNAPSACK,2,1.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,28,KNAPSACK,3,2.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,29,KNAPSACK,4,3.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,30,KNAPSACK,5,4.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,31,KNAPSACK,6,5.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,32,KNAPSACK,7,6.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,33,KNAPSACK,8,7.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,34,KNAPSACK,9,8.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,35,KNAPSACK,10,9.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,36,KNAPSACK,11,10.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,37,KNAPSACK,12,11.0,"Package, import, comment, class declaration, author info — no relevance to logic faults.",0
14,38,KNAPSACK,13,0.0,Blank,0
14,39,KNAPSACK,18,0.0,Blank,0
14,40,KNAPSACK,35,0.0,Blank,0
14,41,KNAPSACK,36,0.0,Blank,0
14,42,KNAPSACK,42,0.0,Blank,0
15,1,KTH,8,1.0,"Directly accesses arr.get(0) without checking if arr is non-empty, causing IndexOutOfBoundsException.",0
15,2,KTH,23,0.95,"Recursively calls kth(below, k) without verifying below is non-empty, risking repeated empty list access.",0
15,3,KTH,25,0.95,"Recursively calls kth(above, k) without verifying above is non-empty, risking repeated empty list access.",1
15,4,KTH,7,0.7,Method header assumes preconditions are met but no internal safeguard against empty arr.,0
15,5,KTH,22,0.5,"Decides to recurse into below, dependent on potentially empty array.",0
15,6,KTH,24,0.5,"Decides to recurse into above, dependent on potentially empty array.",0
15,7,KTH,6,0.3,Class definition; not directly faulty but houses the problematic method.,0
15,8,KTH,20,0.2,Computes num_less but does not independently verify list state.,0
15,9,KTH,21,0.2,Computes num_lessoreq; correctness depends on non-empty partitions.,0
15,10,KTH,12,0.1,"for loop over arr; behavior expected, but if arr empty, no iterations.",0
15,11,KTH,13,0.05,Correctly partitions elements less than pivot.,0
15,12,KTH,15,0.05,Correctly partitions elements greater than pivot.,0
15,13,KTH,14,0.01,Adds elements smaller than pivot to below.,0
15,14,KTH,16,0.01,Adds elements greater than pivot to above.,0
15,15,KTH,26,0.01,Correctly selects pivot when neither recursion condition holds.,0
15,16,KTH,27,0.01,Returns pivot when k is in proper range.,0
15,17,KTH,28,0.01,Normal closing of if-else control block.,0
15,18,KTH,29,0.01,Closing brace for method; no impact.,0
15,19,KTH,30,0.01,Closing brace for class; no impact.,0
15,20,KTH,1,0.0,Package declaration; no impact on bug.,0
15,21,KTH,2,0.0,Import statement; no impact on bug.,0
15,22,KTH,3,0.0,Start of comment block; no impact.,0
15,23,KTH,4,0.0,Empty comment line; no impact.,0
15,24,KTH,5,0.0,End of comment block; no impact.,0
15,25,KTH,9,0.0,Blank,0
15,26,KTH,10,0.0,Blank,0
15,27,KTH,11,0.0,Blank,0
15,28,KTH,17,0.0,Blank,0
15,29,KTH,18,0.0,Blank,0
15,30,KTH,19,0.0,Blank,0
16,1,LCS_LENGTH,33,1.0,"Only updates DP on character match, missing the standard LCS ""max of neighbors"" update for mismatch.",0
16,2,LCS_LENGTH,31,0.95,"Loops through s, but within it, only match-based updates are done, missing updates for non-matches.",0
16,3,LCS_LENGTH,32,0.95,"Loops through t, similarly part of the faulty nested loop missing mismatch handling.",0
16,4,LCS_LENGTH,37,0.9,"Updates only based on previous row and current column upon a match, no update logic for when characters differ.",1
16,5,LCS_LENGTH,35,0.9,The conditional if (dp.containsKey(i-1)) is awkward and unnecessary — standard DP should assume previous values exist or default to 0.,0
16,6,LCS_LENGTH,36,0.8,"Retrieves internal_map, but logic for updating is bound only to match cases.",0
16,7,LCS_LENGTH,38,0.8,"Sets the matched case value, but the method lacks a non-match handling fallback.",0
16,8,LCS_LENGTH,39,0.7,"Reinserts internal_map into dp, potentially redundant because internal_map is already a reference to the value inside dp.",0
16,9,LCS_LENGTH,41,0.6,"Inside the else branch: only assigns 1 if characters match and i-1 is absent, but again no handling of mismatch cases.",0
16,10,LCS_LENGTH,42,0.6,"Puts a hardcoded 1 when first matched, ignoring that subsequence building must be cumulative.",0
16,11,LCS_LENGTH,43,0.6,"Similar issue: reinserts internal_map, possibly redundant and also missing proper chain updates.",0
16,12,LCS_LENGTH,17,0.5,"Initialization of dp structure, although not a direct cause, its overly complex hashtable structure complicates tracing.",0
16,13,LCS_LENGTH,21,0.5,Initializes initialize maps but logic not tied directly to LCS optimal substructure principles.,0
16,14,LCS_LENGTH,24,0.4,"Fetches internal_map again, potential redundancy, slightly confusing for maintenance but minor to the fault.",0
16,15,LCS_LENGTH,25,0.4,Correctly sets initial zeros but may obscure missing default values when later accessing previous cells.,0
16,16,LCS_LENGTH,49,0.4,Checks if dp is empty before extracting results; not faulty by itself but part of a potentially broken chain.,0
16,17,LCS_LENGTH,50,0.3,Starts collecting DP maximums; the error by this point has already been made.,0
16,18,LCS_LENGTH,51,0.3,"Loops through each dp[i] map for max values; processing correct given DP contents, but the source DP is wrong.",0
16,19,LCS_LENGTH,52,0.3,"Picks maximum of each dp[i]; again, propagates wrong values if DP table is faulty.",0
16,20,LCS_LENGTH,54,0.2,Returns overall maximum value from ret_list; logical continuation of previous steps.,0
16,21,LCS_LENGTH,55,0.2,"Returns 0 if dp is empty; not buggy, just fallback behavior.",0
16,22,LCS_LENGTH,56,0.1,Return statement; not buggy independently.,0
16,23,LCS_LENGTH,58,0.0,"Closing brace, irrelevant.",0
16,24,LCS_LENGTH,59,0.0,"Closing brace, irrelevant.",0
16,25,LCS_LENGTH,13,0.0,"Function signature, correct.",0
16,26,LCS_LENGTH,14,0.0,"Comment, no impact.",0
16,27,LCS_LENGTH,15,0.0,"Comment, no impact.",0
16,28,LCS_LENGTH,16,0.0,"Comment, no impact.",0
16,29,LCS_LENGTH,18,0.0,"Initializes DP structure, standard, not a fault source.",0
16,30,LCS_LENGTH,20,0.0,"For-loop for string s, setup step, not fault source itself.",0
16,31,LCS_LENGTH,22,0.0,Puts initialized empty maps in DP; necessary but not the fault.,0
16,32,LCS_LENGTH,23,0.0,"For-loop for string t, again setup, not the bug.",0
16,33,LCS_LENGTH,26,0.0,"Reinserts internal map, redundant but not directly faulty.",0
16,34,LCS_LENGTH,28,0.0,"Ends first loop, neutral.",0
16,35,LCS_LENGTH,30,0.0,"Starts actual LCS logic loop, structure is correct but inner logic wrong.",0
16,36,LCS_LENGTH,34,0.0,"Blank line, no effect.",0
16,37,LCS_LENGTH,40,0.0,"Else branch entry, control structure itself is fine.",0
16,38,LCS_LENGTH,44,0.0,"Ends else branch, neutral.",0
16,39,LCS_LENGTH,45,0.0,"Ends match block, neutral.",0
16,40,LCS_LENGTH,46,0.0,"Ends inner loop, neutral.",0
16,41,LCS_LENGTH,47,0.0,"Ends outer loop, neutral.",0
16,42,LCS_LENGTH,48,0.0,"Blank line, no effect.",0
16,43,LCS_LENGTH,53,0.0,"Ends collection loop, neutral.",0
16,44,LCS_LENGTH,1,0.0,Blank,0
16,45,LCS_LENGTH,2,0.0,Blank,0
16,46,LCS_LENGTH,3,0.0,Blank,0
16,47,LCS_LENGTH,4,0.0,Blank,0
16,48,LCS_LENGTH,5,0.0,Blank,0
16,49,LCS_LENGTH,6,0.0,Blank,0
16,50,LCS_LENGTH,7,0.0,Blank,0
16,51,LCS_LENGTH,8,0.0,Blank,0
16,52,LCS_LENGTH,9,0.0,Blank,0
16,53,LCS_LENGTH,10,0.0,Blank,0
16,54,LCS_LENGTH,11,0.0,Blank,0
16,55,LCS_LENGTH,12,0.0,Blank,0
16,56,LCS_LENGTH,19,0.0,Blank,0
16,57,LCS_LENGTH,27,0.0,Blank,0
16,58,LCS_LENGTH,29,0.0,Blank,0
16,59,LCS_LENGTH,57,0.0,Blank,0
17,1,LEVENSHTEIN,17,1.0,Incorrectly adds 1 when characters match; should recurse without increment to satisfy minimal edit distance specification.,1
17,2,LEVENSHTEIN,16,0.95,Condition where characters match is handled improperly; leads directly to wrong recursion cost.,0
17,3,LEVENSHTEIN,19,0.8,"Part of the main mismatch handling; although likely correct structurally, still needs careful validation given surrounding logic.",0
17,4,LEVENSHTEIN,20,0.7,Recursive call for insertion; affected by overall error propagation.,0
17,5,LEVENSHTEIN,21,0.7,Recursive call for substitution; affected by overall error propagation.,0
17,6,LEVENSHTEIN,22,0.7,Recursive call for deletion; affected by overall error propagation.,0
17,7,LEVENSHTEIN,13,0.5,"Entry point of the function; while generally fine, it initializes logic that leads to incorrect recursive results.",0
17,8,LEVENSHTEIN,18,0.5,Starting point of mismatch handling; transition from match case to edit operations.,0
17,9,LEVENSHTEIN,14,0.2,Base case for empty strings; seems correct but still worth minimal attention since recursion can reach here wrongly.,0
17,10,LEVENSHTEIN,15,0.2,Handles empty source or target; correctly contributes to stopping recursion.,0
17,11,LEVENSHTEIN,23,0.1,"Closing parenthesis for the Math.min block; syntax structure, low chance of being root cause.",0
17,12,LEVENSHTEIN,24,0.05,Closing of else block; no functional logic here.,0
17,13,LEVENSHTEIN,25,0.01,Closing of method; syntactic only.,0
17,14,LEVENSHTEIN,1,0.0,Package declaration; irrelevant to logic.,0
17,15,LEVENSHTEIN,2,0.0,Import statement for java.util.*; standard utility imports.,0
17,16,LEVENSHTEIN,3,0.0,Start of comment block; not executable.,0
17,17,LEVENSHTEIN,4,0.0,Comment text; not executable.,0
17,18,LEVENSHTEIN,5,0.0,Comment text; not executable.,0
17,19,LEVENSHTEIN,6,0.0,End of comment block; not executable.,0
17,20,LEVENSHTEIN,7,0.0,Empty line; irrelevant.,0
17,21,LEVENSHTEIN,8,0.0,Start of JavaDoc; not executable.,0
17,22,LEVENSHTEIN,9,0.0,JavaDoc content; not executable.,0
17,23,LEVENSHTEIN,10,0.0,JavaDoc content; not executable.,0
17,24,LEVENSHTEIN,11,0.0,JavaDoc content; not executable.,0
17,25,LEVENSHTEIN,12,0.0,Class definition line; structure only.,0
17,26,LEVENSHTEIN,26,0.0,Blank,0
18,1,LIS,22,1.0,"The core condition arr[ends.get(j)] < val may not correctly identify the proper prefix, causing incorrect LIS computation.",0
18,2,LIS,29,1.0,"The condition for updating ends and longest may wrongly prevent subsequence extension, leading to underestimation of LIS.",0
18,3,LIS,30,0.95,"Updating ends.put(length+1, i) without ensuring minimal ending values can cause improper LIS formation.",0
18,4,LIS,31,0.9,Incorrectly increasing longest due to flawed prefix computation affects the final output directly.,1
18,5,LIS,21,0.8,"The loop over j values depends on longest, which might already be miscomputed due to previous errors, propagating faults.",0
18,6,LIS,27,0.7,"If prefix_lengths was incorrectly populated, the computed length here will propagate errors.",0
18,7,LIS,18,0.6,"Iterating over arr values; if initialization before this loop is incorrect, it affects the entire LIS computation.",0
18,8,LIS,19,0.4,"Declares prefix_lengths, which may not be populated correctly due to faulty prefix condition checking.",0
18,9,LIS,20,0.35,Start of the inner loop; its correctness depends on the correct longest value and array boundary handling.,0
18,10,LIS,23,0.3,"Adding j to prefix_lengths; although simple, it depends on the correctness of the condition on line 22.",0
18,11,LIS,28,0.25,Computation of length; downstream effect based on previous population of prefix_lengths.,0
18,12,LIS,17,0.2,Initializing index i; unlikely faulty by itself but required for correctly updating ends.,0
18,13,LIS,34,0.15,Increments i; unlikely source of logical error but important for ends indexing.,0
18,14,LIS,14,0.1,Initialization of ends map; may cause problems if not sized or cleared properly (unlikely here).,0
18,15,LIS,15,0.05,Initialization of longest to 0; expected behavior.,0
18,16,LIS,13,0.01,Method signature and input parameters; not suspicious.,0
18,17,LIS,36,0.01,"Return longest; final step, but depends on previous computation.",0
18,18,LIS,1,0.0,Package declaration; not relevant.,0
18,19,LIS,2,0.0,Import statements; not suspicious.,0
18,20,LIS,3,0.0,Comment start; not suspicious.,0
18,21,LIS,4,0.0,Comment; not suspicious.,0
18,22,LIS,5,0.0,Comment end; not suspicious.,0
18,23,LIS,6,0.0,Empty line; no effect.,0
18,24,LIS,8,0.0,JavaDoc comment start; not suspicious.,0
18,25,LIS,9,0.0,JavaDoc content; not suspicious.,0
18,26,LIS,10,0.0,JavaDoc content; not suspicious.,0
18,27,LIS,11,0.0,JavaDoc content; not suspicious.,0
18,28,LIS,12,0.0,Class definition; not suspicious.,0
18,29,LIS,37,0.0,Method end; not suspicious.,0
18,30,LIS,38,0.0,Class end; not suspicious.,0
18,31,LIS,7,0.0,Blank,0
18,32,LIS,16,0.0,Blank,0
18,33,LIS,24,0.0,Blank,0
18,34,LIS,25,0.0,Blank,0
18,35,LIS,26,0.0,Blank,0
18,36,LIS,32,0.0,Blank,0
18,37,LIS,33,0.0,Blank,0
18,38,LIS,35,0.0,Blank,0
19,1,LONGEST_COMMON_SUBSEQUENCE,18,1.0,"Recursion when characters match incorrectly only advances a, not b, violating the SOFL specification for matching heads.",1
19,2,LONGEST_COMMON_SUBSEQUENCE,17,0.95,The branch checking a.charAt(0) == b.charAt(0) is critical and leads directly to faulty recursion.,0
19,3,LONGEST_COMMON_SUBSEQUENCE,20,0.7,"Recursive call for mismatched characters — although structurally correct, it propagates errors from faulty base cases.",0
19,4,LONGEST_COMMON_SUBSEQUENCE,21,0.7,Same as Line 20 — wrong base recursion can taint these alternatives.,0
19,5,LONGEST_COMMON_SUBSEQUENCE,22,0.5,Comparing the lengths of two subsequences may yield wrong results if upstream recursion is flawed.,0
19,6,LONGEST_COMMON_SUBSEQUENCE,14,0.3,Function entry; handling base cases (`a.isEmpty(),0
19,7,LONGEST_COMMON_SUBSEQUENCE,15,0.1,Correctly handles one of the base conditions by returning empty string when either input is empty.,0
19,8,LONGEST_COMMON_SUBSEQUENCE,19,0.1,Else-branch setup for choosing between two alternative subsequences — structurally acceptable.,0
19,9,LONGEST_COMMON_SUBSEQUENCE,16,0.05,"The correct comparison of charAt(0); no logical fault, but links to faulty recursion.",0
19,10,LONGEST_COMMON_SUBSEQUENCE,23,0.05,Returning the longer of two subsequences — logic depends on correctness of fst and snd.,0
19,11,LONGEST_COMMON_SUBSEQUENCE,13,0.01,Method signature; just defines the function longest_common_subsequence.,0
19,12,LONGEST_COMMON_SUBSEQUENCE,25,0.0,Closing bracket of the method — not contributing to logic errors.,0
19,13,LONGEST_COMMON_SUBSEQUENCE,26,0.0,Closing bracket of the class — no relevance to logic.,0
19,14,LONGEST_COMMON_SUBSEQUENCE,1,0.0,Package declaration — irrelevant to bug.,0
19,15,LONGEST_COMMON_SUBSEQUENCE,2,0.0,Import statement — irrelevant to bug.,0
19,16,LONGEST_COMMON_SUBSEQUENCE,3,0.0,Start of comment block — documentation only.,0
19,17,LONGEST_COMMON_SUBSEQUENCE,4,0.0,Comment continuation — documentation only.,0
19,18,LONGEST_COMMON_SUBSEQUENCE,5,0.0,Comment continuation — documentation only.,0
19,19,LONGEST_COMMON_SUBSEQUENCE,6,0.0,End of comment block — documentation only.,0
19,20,LONGEST_COMMON_SUBSEQUENCE,7,0.0,Blank line.,0
19,21,LONGEST_COMMON_SUBSEQUENCE,8,0.0,Start of class-level JavaDoc comment — documentation only.,0
19,22,LONGEST_COMMON_SUBSEQUENCE,9,0.0,Comment line.,0
19,23,LONGEST_COMMON_SUBSEQUENCE,10,0.0,Comment line.,0
19,24,LONGEST_COMMON_SUBSEQUENCE,11,0.0,Author annotation in comment — not code logic.,0
19,25,LONGEST_COMMON_SUBSEQUENCE,12,0.0,Class declaration start — structure only.,0
19,26,LONGEST_COMMON_SUBSEQUENCE,24,0.0,Blank,0
19,27,LONGEST_COMMON_SUBSEQUENCE,27,0.0,Blank,0
20,1,MAX_SUBLIST_SUM,19,1.0,Updates max_ending_here without checking for negativity; critical flaw leading to wrong sublist sum.,1
20,2,MAX_SUBLIST_SUM,20,0.95,"Updates max_so_far based on possibly negative max_ending_here, misaligned with the need to allow resetting sums.",0
20,3,MAX_SUBLIST_SUM,18,0.8,"For-loop control; accumulation strategy is flawed, does not reset when encountering detrimental elements.",0
20,4,MAX_SUBLIST_SUM,15,0.4,"Initial assignment max_ending_here = 0; while correct, no reset later diminishes its value.",0
20,5,MAX_SUBLIST_SUM,16,0.4,Initial assignment max_so_far = 0; matches SOFL’s requirement of empty sublist being 0 but not dynamically corrected later.,0
20,6,MAX_SUBLIST_SUM,14,0.2,"Method signature; correct setup, but indirectly responsible for misalignment of logic inside.",0
20,7,MAX_SUBLIST_SUM,23,0.2,"Returns max_so_far, but as a consequence of incorrect accumulation.",0
20,8,MAX_SUBLIST_SUM,24,0.1,Method closing; correct but relies on previous faulty computation.,0
20,9,MAX_SUBLIST_SUM,3,0.05,Comment block start; irrelevant to computation.,0
20,10,MAX_SUBLIST_SUM,4,0.05,Comment block continuation; irrelevant.,0
20,11,MAX_SUBLIST_SUM,5,0.05,Comment block continuation; irrelevant.,0
20,12,MAX_SUBLIST_SUM,6,0.05,Comment block continuation; irrelevant.,0
20,13,MAX_SUBLIST_SUM,7,0.05,End of comment; irrelevant.,0
20,14,MAX_SUBLIST_SUM,2,0.05,Import statement; correct and necessary.,0
20,15,MAX_SUBLIST_SUM,8,0.05,Javadoc start; irrelevant to logic.,0
20,16,MAX_SUBLIST_SUM,9,0.05,Javadoc continuation; irrelevant.,0
20,17,MAX_SUBLIST_SUM,10,0.05,Javadoc continuation; irrelevant.,0
20,18,MAX_SUBLIST_SUM,11,0.05,Javadoc author tag; irrelevant.,0
20,19,MAX_SUBLIST_SUM,12,0.05,Class declaration start; correct and necessary.,0
20,20,MAX_SUBLIST_SUM,13,0.05,Method declaration start; correct.,0
20,21,MAX_SUBLIST_SUM,17,0.05,Initialization of loop variable i was omitted; not needed here but also not an error.,0
20,22,MAX_SUBLIST_SUM,22,0.05,End of for-loop; neutral.,0
20,23,MAX_SUBLIST_SUM,1,0.0,Blank,0
20,24,MAX_SUBLIST_SUM,21,0.0,Blank,0
20,25,MAX_SUBLIST_SUM,25,0.0,Blank,0
21,1,MERGESORT,38,1.0,"The base case incorrectly checks only arr.size() == 0, missing arr.size() == 1, leading to infinite recursion.",1
21,2,MERGESORT,43,0.95,"arr.subList(0, middle) can create empty sublists when arr.size() is 1, feeding invalid data into recursion.",0
21,3,MERGESORT,46,0.95,"arr.subList(middle, arr.size()) similarly causes non-shrinking recursion with singleton lists.",0
21,4,MERGESORT,44,0.9,"Recursive call on potentially empty left sublists, worsening stack growth.",0
21,5,MERGESORT,47,0.9,"Recursive call on small right sublists without properly reducing size, deepens recursion unnecessarily.",0
21,6,MERGESORT,14,0.4,"Merge function might process improperly divided lists, but less likely the root cause compared to faulty recursion logic.",0
21,7,MERGESORT,24,0.2,Logic in merging left and right; less suspicious since bug occurs before merging stage.,0
21,8,MERGESORT,33,0.2,"Sublist merge handling could misbehave, but primary infinite recursion is unrelated to this line.",0
21,9,MERGESORT,20,0.05,Standard initialization of result list; no direct control flow problem.,0
21,10,MERGESORT,21,0.05,"Index initialization; standard practice, unlikely fault point.",0
21,11,MERGESORT,22,0.05,Index initialization; not controlling recursion.,0
21,12,MERGESORT,25,0.05,"Basic merge comparison logic, unrelated to infinite recursion.",0
21,13,MERGESORT,26,0.05,Standard element addition after comparison; unlikely the fault source.,0
21,14,MERGESORT,27,0.05,Standard increment step; normal.,0
21,15,MERGESORT,28,0.05,Adding right element; normal merge step.,0
21,16,MERGESORT,29,0.05,Increment step after adding from right; normal.,0
21,17,MERGESORT,30,0.05,Loop closure; expected.,0
21,18,MERGESORT,31,0.05,Loop closure; expected.,0
21,19,MERGESORT,32,0.05,Loop closure; expected.,0
21,20,MERGESORT,34,0.05,Return result after merge; normal behavior.,0
21,21,MERGESORT,35,0.0,Function closing; no logic.,0
21,22,MERGESORT,37,0.0,Function declaration of mergesort; no logic fault here.,0
21,23,MERGESORT,39,0.0,"Return when size is 0; although incomplete, by itself not causing StackOverflow.",0
21,24,MERGESORT,40,0.0,"Else branch; structure is fine, problem lies inside.",0
21,25,MERGESORT,41,0.0,middle = arr.size()/2; calculation is fine.,0
21,26,MERGESORT,42,0.0,Creating new left list; normal.,0
21,27,MERGESORT,45,0.0,Creating new right list; normal.,0
21,28,MERGESORT,48,0.0,Merging left and right; merge function itself not the direct issue.,0
21,29,MERGESORT,49,0.0,Returning merged result; normal.,0
21,30,MERGESORT,50,0.0,Else block closure; fine.,0
21,31,MERGESORT,51,0.0,mergesort method closure; fine.,0
21,32,MERGESORT,52,0.0,Class closure; fine.,0
21,33,MERGESORT,1,0.0,Package declaration; irrelevant to bug.,0
21,34,MERGESORT,2,0.0,Imports; not influencing logic.,0
21,35,MERGESORT,3,0.0,Comment start; no effect.,0
21,36,MERGESORT,4,0.0,Comment text; no effect.,0
21,37,MERGESORT,5,0.0,Comment text; no effect.,0
21,38,MERGESORT,6,0.0,Comment end; no effect.,0
21,39,MERGESORT,7,0.0,Blank line; no effect.,0
21,40,MERGESORT,8,0.0,Comment block start; no effect.,0
21,41,MERGESORT,9,0.0,Comment text; no effect.,0
21,42,MERGESORT,10,0.0,Comment text; no effect.,0
21,43,MERGESORT,11,0.0,Comment text; no effect.,0
21,44,MERGESORT,12,0.0,Class definition start; no effect.,0
21,45,MERGESORT,13,0.0,Class name; no logic fault here.,0
21,46,MERGESORT,15,0.0,Commented print statement; inactive.,0
21,47,MERGESORT,16,0.0,Commented print statement; inactive.,0
21,48,MERGESORT,17,0.0,Commented print statement; inactive.,0
21,49,MERGESORT,18,0.0,Commented print statement; inactive.,0
21,50,MERGESORT,19,0.0,Blank,0
21,51,MERGESORT,23,0.0,Blank,0
21,52,MERGESORT,36,0.0,Blank,0
22,1,MINIMUM_SPANNING_TREE,28,1.0,"Inside the iteration, modifies groupByNode by calling update, which changes the structure of the map.",1
22,2,MINIMUM_SPANNING_TREE,27,1.0,Iterating over groupByNode.get(vertex_v) while modifying groupByNode inside the loop causes ConcurrentModificationException.,0
22,3,MINIMUM_SPANNING_TREE,26,0.8,"Updates groupByNode directly before the loop; although safe here, indicates the same risky pattern of modification.",0
22,4,MINIMUM_SPANNING_TREE,24,0.7,"Condition checking group equivalence relies on groupByNode state, prone to inconsistency if modifications are mishandled.",0
22,5,MINIMUM_SPANNING_TREE,35,0.6,"update() method merges sets inside groupByNode, directly responsible for structure modification without cloning.",0
22,6,MINIMUM_SPANNING_TREE,36,0.5,"Retrieves a mutable set reference; modifications propagate immediately to the map, dangerous without defensive copy.",0
22,7,MINIMUM_SPANNING_TREE,37,0.5,"Performs addAll to the retrieved set, indirectly causing map mutation affecting iteration.",0
22,8,MINIMUM_SPANNING_TREE,11,0.2,Collections.sort(weightedEdges) affects input order but is unrelated to concurrent modification issues.,0
22,9,MINIMUM_SPANNING_TREE,13,0.2,"Standard iteration over weightedEdges, no direct fault but sets up the context where the bug later occurs.",0
22,10,MINIMUM_SPANNING_TREE,25,0.2,"Adds an edge to minSpanningTree, normal operation; slight suspicion because it follows a risky condition block.",0
22,11,MINIMUM_SPANNING_TREE,14,0.1,"Assigns vertex_u, only data preparation.",0
22,12,MINIMUM_SPANNING_TREE,15,0.1,"Assigns vertex_v, only data preparation.",0
22,13,MINIMUM_SPANNING_TREE,7,0.1,"Initializes groupByNode, correctly done.",0
22,14,MINIMUM_SPANNING_TREE,8,0.1,"Initializes minSpanningTree, no error.",0
22,15,MINIMUM_SPANNING_TREE,17,0.1,Safely checks if vertex_u exists; not directly faulty but part of pre-update setup.,0
22,16,MINIMUM_SPANNING_TREE,18,0.1,"Creates a new set for vertex_u, correct logic.",0
22,17,MINIMUM_SPANNING_TREE,19,0.1,Safe handling of missing node vertex_v.,0
22,18,MINIMUM_SPANNING_TREE,20,0.1,Similar to Line 18; safe new node handling.,0
22,19,MINIMUM_SPANNING_TREE,21,0.1,Similar to Line 19; safe.,0
22,20,MINIMUM_SPANNING_TREE,29,0.1,"Moves to next node after adding from right or left; standard merge logic, low fault probability.",0
22,21,MINIMUM_SPANNING_TREE,32,0.0,"return minSpanningTree; final return, no fault.",0
22,22,MINIMUM_SPANNING_TREE,6,0.0,"Class definition line, not executable.",0
22,23,MINIMUM_SPANNING_TREE,3,0.0,"Comment, no effect.",0
22,24,MINIMUM_SPANNING_TREE,4,0.0,"Comment, no effect.",0
22,25,MINIMUM_SPANNING_TREE,5,0.0,"Comment, no effect.",0
22,26,MINIMUM_SPANNING_TREE,12,0.0,Blank line.,0
22,27,MINIMUM_SPANNING_TREE,22,0.0,"Initializes index i, safe.",0
22,28,MINIMUM_SPANNING_TREE,23,0.0,"Initializes index j, safe.",0
22,29,MINIMUM_SPANNING_TREE,31,0.0,"End of for-each loop, no direct effect.",0
22,30,MINIMUM_SPANNING_TREE,9,0.0,Empty line.,0
22,31,MINIMUM_SPANNING_TREE,10,0.0,Empty line.,0
22,32,MINIMUM_SPANNING_TREE,38,0.0,"End of update method, safe.",0
22,33,MINIMUM_SPANNING_TREE,39,0.0,"Return updated groupByNode, no direct issue.",0
22,34,MINIMUM_SPANNING_TREE,40,0.0,End of update method.,0
22,35,MINIMUM_SPANNING_TREE,41,0.0,End of class.,0
22,36,MINIMUM_SPANNING_TREE,1,0.0,Blank,0
22,37,MINIMUM_SPANNING_TREE,2,0.0,Blank,0
22,38,MINIMUM_SPANNING_TREE,16,0.0,Blank,0
22,39,MINIMUM_SPANNING_TREE,30,0.0,Blank,0
22,40,MINIMUM_SPANNING_TREE,33,0.0,Blank,0
22,41,MINIMUM_SPANNING_TREE,34,0.0,Blank,0
23,1,NEXT_PALINDROME,38,1.0,return String.valueOf(otherwise); wrongly converts the list to a string with array format rather than a proper digit string.,0
23,2,NEXT_PALINDROME,29,0.95,return Arrays.toString(digit_list); also incorrectly formats the digits as a Java array string instead of concatenating digits.,0
23,3,NEXT_PALINDROME,33,0.7,Constructs otherwise list but no immediate formatting/flattening is considered at construction time.,0
23,4,NEXT_PALINDROME,35,0.5,"Adds zeroes to otherwise correctly, but again impacted by formatting later.",1
23,5,NEXT_PALINDROME,34,0.5,"Adds initial 1 to otherwise — numerically correct, but combined with faulty output handling, contributes indirectly.",0
23,6,NEXT_PALINDROME,36,0.4,"Adds final 1 to otherwise, fine numerically but linked to final faulty output structure.",0
23,7,NEXT_PALINDROME,18,0.2,"Beginning of the while loop, setting up digit-by-digit processing. Overall control correct but contextually related.",0
23,8,NEXT_PALINDROME,19,0.2,"Resets mid digits to 0 when they are 9 — logical, but contributes by leading flow toward faulty ""otherwise"" construction.",0
23,9,NEXT_PALINDROME,25,0.1,"Increments high_mid digit — correct, but connected to flow reaching ""otherwise"" when 9 overflow happens.",0
23,10,NEXT_PALINDROME,26,0.1,"Ensures that when low_mid ≠ high_mid, both sides are incremented — no direct fault but contextually related to wrong flow reaching fallback.",0
23,11,NEXT_PALINDROME,1,0.0,"Package declaration, no relation to logic.",0
23,12,NEXT_PALINDROME,2,0.0,"Import statement, no relation to logic.",0
23,13,NEXT_PALINDROME,3,0.0,"Import statement, no relation to logic.",0
23,14,NEXT_PALINDROME,4,0.0,"Comment block start, irrelevant.",0
23,15,NEXT_PALINDROME,5,0.0,"Comment, no logic impact.",0
23,16,NEXT_PALINDROME,6,0.0,"Comment block end, irrelevant.",0
23,17,NEXT_PALINDROME,7,0.0,"Empty line, no logic impact.",0
23,18,NEXT_PALINDROME,8,0.0,"Javadoc start, no logic impact.",0
23,19,NEXT_PALINDROME,9,0.0,"Javadoc line, no logic impact.",0
23,20,NEXT_PALINDROME,10,0.0,"Javadoc line, no logic impact.",0
23,21,NEXT_PALINDROME,11,0.0,"Javadoc author, no logic impact.",0
23,22,NEXT_PALINDROME,12,0.0,"Javadoc end, no logic impact.",0
23,23,NEXT_PALINDROME,13,0.0,"Class declaration, no direct logic.",0
23,24,NEXT_PALINDROME,14,0.0,"Method declaration, no direct logic.",0
23,25,NEXT_PALINDROME,15,0.0,Compute high_mid index — correct calculation.,0
23,26,NEXT_PALINDROME,16,0.0,Compute low_mid index — correct calculation.,0
23,27,NEXT_PALINDROME,17,0.0,"Empty line, no logic impact.",0
23,28,NEXT_PALINDROME,20,0.0,Sets high_mid and low_mid digits to 0 when overflow occurs — correct behavior.,0
23,29,NEXT_PALINDROME,21,0.0,"Same as line 20, symmetric on low_mid.",0
23,30,NEXT_PALINDROME,22,0.0,Moves high_mid pointer — correct.,0
23,31,NEXT_PALINDROME,23,0.0,Moves low_mid pointer — correct.,0
23,32,NEXT_PALINDROME,24,0.0,Else branch setup — correct.,0
23,33,NEXT_PALINDROME,27,0.0,"If low_mid ≠ high_mid, also increment low_mid digit — correct and careful.",0
23,34,NEXT_PALINDROME,28,0.0,End of else branch — correct structure.,0
23,35,NEXT_PALINDROME,30,0.0,End of while loop block — fine.,0
23,36,NEXT_PALINDROME,31,0.0,End of while loop — no issue.,0
23,37,NEXT_PALINDROME,32,0.0,"Empty line, no logic impact.",0
23,38,NEXT_PALINDROME,37,0.0,Empty line before fallback return — not suspicious.,0
23,39,NEXT_PALINDROME,39,0.0,End of method — no issue.,0
23,40,NEXT_PALINDROME,40,0.0,End of class — no issue.,0
24,1,NEXT_PERMUTATION,19,1.0,CRITICAL: Wrong comparison direction (perm.get(j) < perm.get(i)) — should be > to find minimal larger element.,1
24,2,NEXT_PERMUTATION,20,0.9,Severe aliasing: next_perm = perm modifies input directly without copying.,0
24,3,NEXT_PERMUTATION,27,0.8,Suffix reversal logic: the range k != i is wrong — leads to missing or misordered elements.,0
24,4,NEXT_PERMUTATION,28,0.8,Collects reversed elements; relies on wrong reversal logic.,0
24,5,NEXT_PERMUTATION,29,0.8,Collects reversed elements; relies on wrong reversal logic.,0
24,6,NEXT_PERMUTATION,21,0.7,"Assignment to temp variables, logically correct but depends on line 20 being wrong.",0
24,7,NEXT_PERMUTATION,22,0.7,"Assignment to temp variables, logically correct but depends on line 20 being wrong.",0
24,8,NEXT_PERMUTATION,23,0.7,Swapping; fine if no aliasing issue (but suffers here).,0
24,9,NEXT_PERMUTATION,24,0.7,Swapping; fine if no aliasing issue (but suffers here).,0
24,10,NEXT_PERMUTATION,37,0.7,Premature return after incomplete suffix fix: should ensure full correct sequence after swap.,0
24,11,NEXT_PERMUTATION,32,0.6,Overwrites values with reversed; method wrong if reversal was wrong.,0
24,12,NEXT_PERMUTATION,33,0.6,Overwrites values with reversed; method wrong if reversal was wrong.,0
24,13,NEXT_PERMUTATION,26,0.4,"Initializes reversed list; fine, but later suffix reversal logic problematic.",0
24,14,NEXT_PERMUTATION,31,0.4,Prepares index for suffix update; fine but indirectly affected.,0
24,15,NEXT_PERMUTATION,43,0.4,Returns empty list if no permutation found; correct but shouldn't happen for non-maximal perms.,0
24,16,NEXT_PERMUTATION,16,0.3,Loop setup is fine but starting from size-2 introduces dependency on correct inside logic.,0
24,17,NEXT_PERMUTATION,17,0.3,"First-level comparison setup (perm.get(i) < perm.get(i+1)), necessary and correct.",0
24,18,NEXT_PERMUTATION,18,0.3,Inner loop setup; fine unless swap condition is wrong.,0
24,19,NEXT_PERMUTATION,15,0.1,Method start; initializes iteration; fine.,0
24,20,NEXT_PERMUTATION,1,0.0,Package import; no logical issue.,0
24,21,NEXT_PERMUTATION,2,0.0,Importing utilities; not faulty.,0
24,22,NEXT_PERMUTATION,3,0.0,Import (unused); no impact.,0
24,23,NEXT_PERMUTATION,4,0.0,Comment line; no effect.,0
24,24,NEXT_PERMUTATION,5,0.0,Comment line; no effect.,0
24,25,NEXT_PERMUTATION,6,0.0,Comment line; no effect.,0
24,26,NEXT_PERMUTATION,7,0.0,Comment line; no effect.,0
24,27,NEXT_PERMUTATION,8,0.0,Empty line; no effect.,0
24,28,NEXT_PERMUTATION,9,0.0,Comment line; no effect.,0
24,29,NEXT_PERMUTATION,10,0.0,Comment line; no effect.,0
24,30,NEXT_PERMUTATION,11,0.0,Comment line; no effect.,0
24,31,NEXT_PERMUTATION,12,0.0,Comment line; no effect.,0
24,32,NEXT_PERMUTATION,13,0.0,Class definition; no issue itself.,0
24,33,NEXT_PERMUTATION,14,0.0,Method signature; correct structure.,0
24,34,NEXT_PERMUTATION,25,0.0,Empty line for clarity; no issue.,0
24,35,NEXT_PERMUTATION,30,0.0,Empty line for clarity; no issue.,0
24,36,NEXT_PERMUTATION,34,0.0,Empty line for clarity; no issue.,0
24,37,NEXT_PERMUTATION,35,0.0,End of swap-reversal logic; return soon.,0
24,38,NEXT_PERMUTATION,36,0.0,Empty line for clarity; no issue.,0
24,39,NEXT_PERMUTATION,38,0.0,No action (closing inner loop); fine.,0
24,40,NEXT_PERMUTATION,39,0.0,No action (closing inner loop); fine.,0
24,41,NEXT_PERMUTATION,40,0.0,No action (closing outer loop); fine.,0
24,42,NEXT_PERMUTATION,41,0.0,No action (closing outer loop); fine.,0
24,43,NEXT_PERMUTATION,42,0.0,Empty line for clarity; no issue.,0
24,44,NEXT_PERMUTATION,44,0.0,Method end.,0
24,45,NEXT_PERMUTATION,45,0.0,Class end.,0
25,1,PASCAL,27,1.0,"Loop c < r creates only r elements per row, but Pascal’s Triangle requires r+1 elements — causing incomplete rows and later crashes.",0
25,2,PASCAL,30,1.0,"Accessing rows.get(r-1).get(c) assumes previous row has enough elements, but the previous row might be incomplete due to wrong loop bounds.",0
25,3,PASCAL,31,0.9,Special case when c < r is not handled correctly; missing explicit initialization for the end of each row (row[r] = 1).,0
25,4,PASCAL,18,0.6,While loop starting structure — sets up how many columns to fill; relies on outer structure correctness.,0
25,5,PASCAL,21,0.5,Fetching upper-left value (upleft) assumes that the boundary case (c=0) is correctly managed; indirect cause of wrong sums if rows are short.,0
25,6,PASCAL,23,0.5,Fetching upper-right value (upright); similar risk if row length mismatch occurs.,0
25,7,PASCAL,15,0.4,"Function start, initial for setup; if perm is null or improperly initialized, downstream errors happen.",0
25,8,PASCAL,14,0.2,"Function signature; if input n is incorrectly passed as ≤0, it could cause empty rows.",0
25,9,PASCAL,16,0.2,"Creating an empty list row; no inherent problem here, but depends on later correct filling.",0
25,10,PASCAL,22,0.1,Boundary check if (c > 0) for upleft; minor compared to main structural mistakes.,1
25,11,PASCAL,19,0.1,Initializing rows list; structure is fine if later filled properly.,0
25,12,PASCAL,20,0.1,Initializing init as [1] for first row; correctly done.,0
25,13,PASCAL,5,0.0,Comment line; no effect.,0
25,14,PASCAL,6,0.0,Comment line; no effect.,0
25,15,PASCAL,7,0.0,Comment line; no effect.,0
25,16,PASCAL,9,0.0,Javadoc start; no effect.,0
25,17,PASCAL,10,0.0,Empty Javadoc line.,0
25,18,PASCAL,11,0.0,Author line; no effect.,0
25,19,PASCAL,12,0.0,Empty line; no effect.,0
25,20,PASCAL,1,0.0,Package statement; no effect.,0
25,21,PASCAL,2,0.0,Import statement; no effect.,0
25,22,PASCAL,3,0.0,Import statement; no effect.,0
25,23,PASCAL,4,0.0,Start of comment block.,0
25,24,PASCAL,8,0.0,Empty line.,0
25,25,PASCAL,13,0.0,Class definition; correct.,0
25,26,PASCAL,17,0.0,"Loop setup for (r=1; r<n; r++); standard structure, no fault.",0
25,27,PASCAL,24,0.0,Else branch assigning upleft = 0; correct.,0
25,28,PASCAL,25,0.0,If checking for c < r; standard handling.,0
25,29,PASCAL,26,0.0,Else branch assigning upright = 0; correct.,0
25,30,PASCAL,28,0.0,row.add(upleft + upright); actual addition is fine if inputs are correct.,0
25,31,PASCAL,29,0.0,rows.add(row); correctly adds new row.,0
25,32,PASCAL,32,0.0,return rows; return statement itself is fine.,0
25,33,PASCAL,33,0.0,Blank,0
25,34,PASCAL,34,0.0,Blank,0
25,35,PASCAL,35,0.0,Blank,0
25,36,PASCAL,36,0.0,Blank,0
25,37,PASCAL,37,0.0,Blank,0
25,38,PASCAL,38,0.0,Blank,0
25,39,PASCAL,39,0.0,Blank,0
25,40,PASCAL,40,0.0,Blank,0
25,41,PASCAL,41,0.0,Blank,0
26,1,POSSIBLE_CHANGE,17,1.0,"Correctly handles total < 0, but not enough to stop issues if coins is empty.",1
26,2,POSSIBLE_CHANGE,21,0.9,"Direct access to coins[0] without checking if coins.length == 0, causes ArrayIndexOutOfBoundsException.",0
26,3,POSSIBLE_CHANGE,23,0.95,"Recursively calls possible_change(rest, total) without checking if rest is empty, leading to infinite recursion and crash.",0
26,4,POSSIBLE_CHANGE,22,0.8,"Creates rest via Arrays.copyOfRange, but the main issue comes before this; still related because it influences recursive structure.",0
26,5,POSSIBLE_CHANGE,13,0.7,"No initial check for empty coins array at the beginning of the method, which would prevent later crashes.",0
26,6,POSSIBLE_CHANGE,14,0.3,Correctly handles total == 0 case; relatively safe but still early logic.,0
26,7,POSSIBLE_CHANGE,18,0.2,"While loop condition indirectly leads to recursion if not managed, but not root cause.",0
26,8,POSSIBLE_CHANGE,19,0.2,"Correct numeric adjustment (total - first), itself not buggy but influenced by unsafe access at Line 21.",0
26,9,POSSIBLE_CHANGE,20,0.2,Safe guard for negative totals; not causing the bug.,0
26,10,POSSIBLE_CHANGE,24,0.1,"Closing bracket for the method, safe.",0
26,11,POSSIBLE_CHANGE,1,0.0,"Package declaration, irrelevant.",0
26,12,POSSIBLE_CHANGE,2,0.0,"Import statements, irrelevant.",0
26,13,POSSIBLE_CHANGE,3,0.0,"Start of comment, irrelevant.",0
26,14,POSSIBLE_CHANGE,4,0.0,"Comment continuation, irrelevant.",0
26,15,POSSIBLE_CHANGE,5,0.0,"Comment continuation, irrelevant.",0
26,16,POSSIBLE_CHANGE,6,0.0,"Comment continuation, irrelevant.",0
26,17,POSSIBLE_CHANGE,7,0.0,"Blank line, irrelevant.",0
26,18,POSSIBLE_CHANGE,8,0.0,"Start of Javadoc comment, irrelevant.",0
26,19,POSSIBLE_CHANGE,9,0.0,"Javadoc line, irrelevant.",0
26,20,POSSIBLE_CHANGE,10,0.0,"Javadoc line, irrelevant.",0
26,21,POSSIBLE_CHANGE,11,0.0,"Javadoc line, irrelevant.",0
26,22,POSSIBLE_CHANGE,12,0.0,"Class declaration line, safe.",0
26,23,POSSIBLE_CHANGE,15,0.0,Blank,0
26,24,POSSIBLE_CHANGE,16,0.0,Blank,0
26,25,POSSIBLE_CHANGE,25,0.0,Blank,0
27,1,POWERSET,23,1.0,"to_add.addAll(subset) incorrectly merges all elements into to_add, losing separate subset structures; invalid for powerset.",1
27,2,POWERSET,17,1.0,"arr.remove(0) mutates the input list destructively, causing wrong subset generation; violates pure function design.",0
27,3,POWERSET,18,0.85,"ArrayList rest = arr; wrongly shares reference with arr after mutation, not creating an independent copy for recursion.",0
27,4,POWERSET,19,0.7,"Calls powerset(rest) on a modified array; since rest and arr share structure, recursion behaves incorrectly.",0
27,5,POWERSET,25,0.6,"Reinforces the incorrect accumulation of subset elements due to addAll, compounding the earlier structural flaw.",1
27,6,POWERSET,27,0.5,"Adds the faulty to_add to output, leading to incomplete/inaccurate powerset generation.",0
27,7,POWERSET,14,0.2,Function signature uses raw ArrayList without generic types; may lead to type unsafety.,0
27,8,POWERSET,22,0.15,Initializes to_add with capacity 100 unnecessarily; does not cause the bug but could be inefficient.,0
27,9,POWERSET,16,0.1,"Object first = arr.get(0); is not itself a problem, but depends on arr.remove(0) (line 17) leading to later bugs.",0
27,10,POWERSET,31,0.05,"Correctly creates empty set, but minor risk if the list is not handled carefully.",0
27,11,POWERSET,32,0.05,Correctly adds empty list for base case; no major issues here.,0
27,12,POWERSET,33,0.01,Correct return of empty set for base case; low suspicion.,0
27,13,POWERSET,15,0.01,Correct conditional check !arr.isEmpty(); very low suspicion.,0
27,14,POWERSET,34,0.01,Correctly ends the else block; not suspicious.,0
27,15,POWERSET,29,0.0,"Standard boilerplate, no impact on logic.",1
27,16,POWERSET,35,0.0,End of method; not suspicious.,0
27,17,POWERSET,1,0.0,"Standard boilerplate, no impact on logic.",0
27,18,POWERSET,2,0.0,"Standard boilerplate, no impact on logic.",0
27,19,POWERSET,3,0.0,"Standard boilerplate, no impact on logic.",0
27,20,POWERSET,4,0.0,"Standard boilerplate, no impact on logic.",0
27,21,POWERSET,5,0.0,"Standard boilerplate, no impact on logic.",0
27,22,POWERSET,6,0.0,"Standard boilerplate, no impact on logic.",0
27,23,POWERSET,7,0.0,"Standard boilerplate, no impact on logic.",0
27,24,POWERSET,8,0.0,"Standard boilerplate, no impact on logic.",0
27,25,POWERSET,9,0.0,"Standard boilerplate, no impact on logic.",0
27,26,POWERSET,10,0.0,"Standard boilerplate, no impact on logic.",0
27,27,POWERSET,11,0.0,"Standard boilerplate, no impact on logic.",0
27,28,POWERSET,12,0.0,"Standard boilerplate, no impact on logic.",0
27,29,POWERSET,13,0.0,"Standard boilerplate, no impact on logic.",0
27,30,POWERSET,20,0.0,Blank,0
27,31,POWERSET,21,0.0,Blank,0
27,32,POWERSET,24,0.0,Blank,0
27,33,POWERSET,26,0.0,Blank,0
27,34,POWERSET,28,0.0,Blank,0
27,35,POWERSET,30,0.0,Blank,0
27,36,POWERSET,36,0.0,Blank,0
28,1,QUICKSORT,24,1.0,"Only < pivot is handled, no == pivot branch — causes loss of duplicates equal to pivot.",0
28,2,QUICKSORT,26,0.95,"Only > pivot is handled in else if, ignoring duplicates again.",1
28,3,QUICKSORT,19,0.85,"Pivot selection from arr.get(0), assumes correct pivot but later logic does not correctly account for equal elements.",0
28,4,QUICKSORT,23,0.8,"Iteration over arr.subList(1, arr.size()); critical loop where misclassification happens.",0
28,5,QUICKSORT,30,0.6,"Initializes middle with only the pivot itself, ignoring multiple occurrences of pivot value.",0
28,6,QUICKSORT,31,0.6,"Adds only one pivot value into middle, even if multiple pivots exist.",0
28,7,QUICKSORT,34,0.5,"Adds all of greater to middle, assumes no missing elements, which is incorrect if equal elements were lost.",0
28,8,QUICKSORT,35,0.5,"Adds middle to lesser, final step — if previous mistakes exist, wrong output is produced.",0
28,9,QUICKSORT,32,0.3,Recursive call on lesser; impact depends on correct partitioning above.,0
28,10,QUICKSORT,33,0.3,Recursive call on greater; same issue.,0
28,11,QUICKSORT,15,0.1,"Empty list check; correctly handled, unlikely related.",0
28,12,QUICKSORT,16,0.05,Returns empty list for empty input; logic seems correct.,0
28,13,QUICKSORT,14,0.05,Method declaration; unlikely fault.,0
28,14,QUICKSORT,36,0.05,"Final return of lesser, depends on earlier assembly steps.",0
28,15,QUICKSORT,3,0.01,Package/imports/comments/header — no impact on fault.,0
28,16,QUICKSORT,4,0.01,Package/imports/comments/header — no impact on fault.,0
28,17,QUICKSORT,5,0.01,Package/imports/comments/header — no impact on fault.,0
28,18,QUICKSORT,6,0.01,Package/imports/comments/header — no impact on fault.,0
28,19,QUICKSORT,7,0.01,Package/imports/comments/header — no impact on fault.,0
28,20,QUICKSORT,8,0.01,Package/imports/comments/header — no impact on fault.,0
28,21,QUICKSORT,9,0.01,Package/imports/comments/header — no impact on fault.,0
28,22,QUICKSORT,10,0.01,Package/imports/comments/header — no impact on fault.,0
28,23,QUICKSORT,11,0.01,Package/imports/comments/header — no impact on fault.,0
28,24,QUICKSORT,12,0.01,Package/imports/comments/header — no impact on fault.,0
28,25,QUICKSORT,1,0.01,Package and imports; no impact on functionality.,0
28,26,QUICKSORT,2,0.01,Package and imports; no impact on functionality.,0
28,27,QUICKSORT,13,0.01,"Class declaration; structural, not functional.",0
28,28,QUICKSORT,17,0.01,Braces for if (arr.isEmpty()) block — fine.,0
28,29,QUICKSORT,18,0.01,Spacer line — no effect.,0
28,30,QUICKSORT,20,0.01,lesser initialization — correct.,0
28,31,QUICKSORT,21,0.01,greater initialization — correct.,0
28,32,QUICKSORT,22,0.01,Spacer line — no effect.,0
28,33,QUICKSORT,27,0.01,Braces closing the for-loop and else-ifs — structural.,0
28,34,QUICKSORT,28,0.01,Braces closing the for-loop and else-ifs — structural.,0
28,35,QUICKSORT,29,0.01,Braces closing the for-loop and else-ifs — structural.,0
28,36,QUICKSORT,37,0.01,Spacer and end of method — no impact.,0
28,37,QUICKSORT,38,0.01,Spacer and end of method — no impact.,0
28,38,QUICKSORT,39,0.01,Spacer and end of method — no impact.,0
28,39,QUICKSORT,25,0.0,Blank,0
29,1,REVERSE_LINKED_LIST,19,1.0,node.setSuccessor(prevnode); incorrectly sets successor but prevnode is never updated.,0
29,2,REVERSE_LINKED_LIST,20,0.95,"node = nextnode; moves forward, but without proper chain reversal due to missing prevnode update.",1
29,3,REVERSE_LINKED_LIST,15,0.9,"Node prevnode = null; initializes correctly, but the variable is never updated during traversal.",0
29,4,REVERSE_LINKED_LIST,22,0.7,return prevnode; returns null or wrong node because prevnode is not maintained properly.,0
29,5,REVERSE_LINKED_LIST,14,0.7,"public static Node reverse_linked_list(Node node) method signature expects correct reversal, but method logic is broken.",0
29,6,REVERSE_LINKED_LIST,18,0.5,nextnode = node.getSuccessor(); saves next node correctly but incomplete reversal logic.,0
29,7,REVERSE_LINKED_LIST,17,0.3,while (node != null) { correctly loops over nodes but inside operations are wrong.,0
29,8,REVERSE_LINKED_LIST,16,0.1,"Node nextnode; variable declaration is normal, no direct fault.",0
29,9,REVERSE_LINKED_LIST,23,0.0,} method closing brace; syntactically correct.,0
29,10,REVERSE_LINKED_LIST,21,0.0,} loop closing brace; syntactically correct.,0
29,11,REVERSE_LINKED_LIST,13,0.0,"public class REVERSE_LINKED_LIST { class definition, unrelated to fault.",0
29,12,REVERSE_LINKED_LIST,12,0.0,*/ comment block ending.,0
29,13,REVERSE_LINKED_LIST,11,0.0,"* @author derricklin comment line, not code logic.",0
29,14,REVERSE_LINKED_LIST,10,0.0,* comment line.,0
29,15,REVERSE_LINKED_LIST,9,0.0,/** comment block start.,0
29,16,REVERSE_LINKED_LIST,8,0.0,} closing the editor template comment block.,0
29,17,REVERSE_LINKED_LIST,7,0.0,* and open the template in the editor. comment line.,0
29,18,REVERSE_LINKED_LIST,6,0.0,"`* To change this template, choose Tools",0
29,19,REVERSE_LINKED_LIST,5,0.0,/* comment block start.,0
29,20,REVERSE_LINKED_LIST,4,0.0,import java.util.*; import statement; no relation to fault.,0
29,21,REVERSE_LINKED_LIST,3,0.0,blank line,0
29,22,REVERSE_LINKED_LIST,2,0.0,"import java.util.*; import for utilities, no fault relation.",0
29,23,REVERSE_LINKED_LIST,1,0.0,"package java_programs; package declaration, unrelated to bug.",0
29,24,REVERSE_LINKED_LIST,24,0.0,Blank,0
30,1,RPN_EVAL,30,1.0,Pops the first operand into a instead of treating it as the right operand; this reverses operand order and breaks subtraction and division.,0
30,2,RPN_EVAL,31,0.95,Pops the second operand into b but applies it incorrectly; control/data flow is violated.,0
30,3,RPN_EVAL,34,0.9,"Applies bin_op.apply(a,b) instead of apply(left, right), causing wrong arithmetic outcomes.",1
30,4,RPN_EVAL,33,0.5,Retrieves binary operator from map but assumes it can be safely applied without checking operand order.,0
30,5,RPN_EVAL,29,0.4,"Casts token to String, assuming all non-Double tokens are valid operators; can lead to subtle issues if operand order misaligns.",0
30,6,RPN_EVAL,32,0.2,"Initializes c = 0.0; not harmful, but indicates poor initialization practice since overwritten immediately.",0
30,7,RPN_EVAL,28,0.1,No major issue; pushing operands to stack is standard; low suspicion.,0
30,8,RPN_EVAL,27,0.1,Pushes a Double operand onto the stack correctly; no major issue.,0
30,9,RPN_EVAL,39,0.1,Pops and returns final result; okay as long as stack evaluation is correct upstream.,0
30,10,RPN_EVAL,15,0.05,Defines the method; not logically suspicious but relevant as entry point.,0
30,11,RPN_EVAL,23,0.05,"Initializes a Stack; minor suspicion if type information is incomplete (e.g., raw type usage).",0
30,12,RPN_EVAL,25,0.05,"Main loop over tokens; logic error stems from operations inside, not iteration itself.",0
30,13,RPN_EVAL,26,0.0,Checks if token is a Double; logical and correct condition.,0
30,14,RPN_EVAL,35,0.0,Pushes computed result back into stack; logically consistent.,0
30,15,RPN_EVAL,36,0.0,"Closing else block; no logic inside, just structure.",0
30,16,RPN_EVAL,37,0.0,"Loop end; structural, not computational.",0
30,17,RPN_EVAL,16,0.0,Creates operator map; normal operation.,0
30,18,RPN_EVAL,17,0.0,Correct addition operator definition.,0
30,19,RPN_EVAL,18,0.0,Correct subtraction operator definition.,0
30,20,RPN_EVAL,19,0.0,Correct multiplication operator definition.,0
30,21,RPN_EVAL,20,0.0,Correct division operator definition.,0
30,22,RPN_EVAL,3,0.0,Java import (BinaryOperator); standard and necessary.,0
30,23,RPN_EVAL,2,0.0,Java import (util); standard and necessary.,0
30,24,RPN_EVAL,1,0.0,Package declaration; no impact on logic.,0
30,25,RPN_EVAL,4,0.0,Comment template; non-executable.,0
30,26,RPN_EVAL,5,0.0,Comment template; non-executable.,0
30,27,RPN_EVAL,6,0.0,Comment template; non-executable.,0
30,28,RPN_EVAL,7,0.0,Comment template; non-executable.,0
30,29,RPN_EVAL,8,0.0,Comment template; non-executable.,0
30,30,RPN_EVAL,9,0.0,Class-level comments and author annotation; non-executable.,0
30,31,RPN_EVAL,10,0.0,Class-level comments and author annotation; non-executable.,0
30,32,RPN_EVAL,11,0.0,Class-level comments and author annotation; non-executable.,0
30,33,RPN_EVAL,12,0.0,Class-level comments and author annotation; non-executable.,0
30,34,RPN_EVAL,14,0.0,Class declaration public class RPN_EVAL; structural.,0
30,35,RPN_EVAL,21,0.0,Empty line; formatting.,0
30,36,RPN_EVAL,22,0.0,Empty line; formatting.,0
30,37,RPN_EVAL,24,0.0,Another empty line; formatting.,0
30,38,RPN_EVAL,38,0.0,Empty line; formatting.,0
30,39,RPN_EVAL,40,0.0,Empty line; formatting.,0
30,40,RPN_EVAL,41,0.0,Class end; structural.,0
30,41,RPN_EVAL,13,0.0,Blank,0
31,1,SHORTEST_PATH_LENGTH,38,1.0,"Wrong addition: uses unvisitedNodes.get(nextnode) instead of distance, causing integer overflow and wrong updates.",1
31,2,SHORTEST_PATH_LENGTH,37,0.95,"The logic incorrectly relies on the current value in unvisitedNodes, making path updates incorrect.",0
31,3,SHORTEST_PATH_LENGTH,34,0.8,"Initializes distance to Integer.MAX_VALUE, which is acceptable but becomes risky if improperly updated later.",0
31,4,SHORTEST_PATH_LENGTH,20,0.3,"Retrieves distance from unvisited node list — works fine if updates are correct, but wrong update logic affects it.",0
31,5,SHORTEST_PATH_LENGTH,28,0.2,Iteration over successors; contextually important but itself not faulty.,0
31,6,SHORTEST_PATH_LENGTH,19,0.2,Selects the node with minimal tentative distance — safe if distances are correct.,0
31,7,SHORTEST_PATH_LENGTH,33,0.15,Checks for null before initializing a node in unvisited; standard check but interacts with later faulty updates.,0
31,8,SHORTEST_PATH_LENGTH,23,0.05,Goal node comparison — simple but depends on correct path finding earlier.,0
31,9,SHORTEST_PATH_LENGTH,24,0.05,"Returns the computed distance, vulnerable if path computation is wrong.",0
31,10,SHORTEST_PATH_LENGTH,45,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,11,SHORTEST_PATH_LENGTH,46,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,12,SHORTEST_PATH_LENGTH,47,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,13,SHORTEST_PATH_LENGTH,48,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,14,SHORTEST_PATH_LENGTH,49,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,15,SHORTEST_PATH_LENGTH,50,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,16,SHORTEST_PATH_LENGTH,51,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,17,SHORTEST_PATH_LENGTH,52,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,18,SHORTEST_PATH_LENGTH,53,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,19,SHORTEST_PATH_LENGTH,54,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,20,SHORTEST_PATH_LENGTH,55,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,21,SHORTEST_PATH_LENGTH,56,0.05,"The helper method getNodeWithMinDistance works correctly, but its effectiveness depends on accurate distance values.",0
31,22,SHORTEST_PATH_LENGTH,21,0.05,Removes node from unvisited; standard behavior.,0
31,23,SHORTEST_PATH_LENGTH,26,0.02,Adds node to visited — correct normal behavior.,0
31,24,SHORTEST_PATH_LENGTH,10,0.01,Initialization of structures; correct high-level setup.,0
31,25,SHORTEST_PATH_LENGTH,11,0.01,Initialization of structures; correct high-level setup.,0
31,26,SHORTEST_PATH_LENGTH,12,0.01,Initialization of structures; correct high-level setup.,0
31,27,SHORTEST_PATH_LENGTH,13,0.01,Initialization of structures; correct high-level setup.,0
31,28,SHORTEST_PATH_LENGTH,14,0.01,Initialization of structures; correct high-level setup.,0
31,29,SHORTEST_PATH_LENGTH,15,0.01,Initialization of structures; correct high-level setup.,0
31,30,SHORTEST_PATH_LENGTH,16,0.01,Initialization of structures; correct high-level setup.,0
31,31,SHORTEST_PATH_LENGTH,17,0.01,Initialization of structures; correct high-level setup.,0
31,32,SHORTEST_PATH_LENGTH,18,0.01,Initialization of structures; correct high-level setup.,0
31,33,SHORTEST_PATH_LENGTH,42,0.01,Correctly returns Integer.MAX_VALUE if no path is found — matches SOFL spec.,0
31,34,SHORTEST_PATH_LENGTH,1,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,35,SHORTEST_PATH_LENGTH,2,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,36,SHORTEST_PATH_LENGTH,3,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,37,SHORTEST_PATH_LENGTH,4,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,38,SHORTEST_PATH_LENGTH,5,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,39,SHORTEST_PATH_LENGTH,6,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,40,SHORTEST_PATH_LENGTH,7,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,41,SHORTEST_PATH_LENGTH,8,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,42,SHORTEST_PATH_LENGTH,9,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,43,SHORTEST_PATH_LENGTH,57,0.0,Package/imports/class/method signatures or closing braces — no logical impact.,0
31,44,SHORTEST_PATH_LENGTH,22,0.0,Blank,0
31,45,SHORTEST_PATH_LENGTH,25,0.0,Blank,0
31,46,SHORTEST_PATH_LENGTH,27,0.0,Blank,0
31,47,SHORTEST_PATH_LENGTH,29,0.0,Blank,0
31,48,SHORTEST_PATH_LENGTH,30,0.0,Blank,0
31,49,SHORTEST_PATH_LENGTH,31,0.0,Blank,0
31,50,SHORTEST_PATH_LENGTH,32,0.0,Blank,0
31,51,SHORTEST_PATH_LENGTH,35,0.0,Blank,0
31,52,SHORTEST_PATH_LENGTH,36,0.0,Blank,0
31,53,SHORTEST_PATH_LENGTH,39,0.0,Blank,0
31,54,SHORTEST_PATH_LENGTH,40,0.0,Blank,0
31,55,SHORTEST_PATH_LENGTH,41,0.0,Blank,0
31,56,SHORTEST_PATH_LENGTH,43,0.0,Blank,0
31,57,SHORTEST_PATH_LENGTH,44,0.0,Blank,0
32,1,SHORTEST_PATH_LENGTHS,36,1.0,"Critical logic flaw: Incorrectly combines (i,k) and (j,k) instead of (i,k) and (k,j), directly causing wrong path computation.",0
32,2,SHORTEST_PATH_LENGTHS,37,0.95,"Relies on the wrong combined length from Line 36, causing wrong updates in the distance map.",1
32,3,SHORTEST_PATH_LENGTHS,35,0.85,Math.min(...) logic depends on wrong inputs from Line 36-37; contributes to accepting wrong minimums.,0
32,4,SHORTEST_PATH_LENGTHS,38,0.7,"Updates the length_by_path map with the incorrect update_length, resulting in persistent wrong paths.",0
32,5,SHORTEST_PATH_LENGTHS,21,0.3,Potential minor confusion if edges are not consistently formatted; but not a major cause here.,0
32,6,SHORTEST_PATH_LENGTHS,25,0.2,"Edge presence check is okay; slight risk if edge keys are inconsistent, but not main bug.",0
32,7,SHORTEST_PATH_LENGTHS,28,0.15,"Assigns INF if no edge exists; standard logic, low suspicion.",0
32,8,SHORTEST_PATH_LENGTHS,45,0.1,sumLengths method correctly handles INF cases; negligible contribution to the bug.,0
32,9,SHORTEST_PATH_LENGTHS,46,0.1,sumLengths method correctly handles INF cases; negligible contribution to the bug.,0
32,10,SHORTEST_PATH_LENGTHS,47,0.1,sumLengths method correctly handles INF cases; negligible contribution to the bug.,0
32,11,SHORTEST_PATH_LENGTHS,48,0.1,sumLengths method correctly handles INF cases; negligible contribution to the bug.,0
32,12,SHORTEST_PATH_LENGTHS,49,0.1,sumLengths method correctly handles INF cases; negligible contribution to the bug.,0
32,13,SHORTEST_PATH_LENGTHS,50,0.1,sumLengths method correctly handles INF cases; negligible contribution to the bug.,0
32,14,SHORTEST_PATH_LENGTHS,17,0.05,Method entry point; correctly initializes result structure.,0
32,15,SHORTEST_PATH_LENGTHS,22,0.05,Properly initializes self-path distances to zero.,0
32,16,SHORTEST_PATH_LENGTHS,23,0.05,Properly initializes self-path distances to zero.,0
32,17,SHORTEST_PATH_LENGTHS,24,0.05,Properly initializes self-path distances to zero.,0
32,18,SHORTEST_PATH_LENGTHS,18,0.05,Loop structures correctly iterate over node pairs.,0
32,19,SHORTEST_PATH_LENGTHS,19,0.05,Loop structures correctly iterate over node pairs.,0
32,20,SHORTEST_PATH_LENGTHS,20,0.05,Loop structures correctly iterate over node pairs.,0
32,21,SHORTEST_PATH_LENGTHS,32,0.05,Loop structures for Floyd-Warshall; iteration logic is standard.,0
32,22,SHORTEST_PATH_LENGTHS,33,0.05,Loop structures for Floyd-Warshall; iteration logic is standard.,0
32,23,SHORTEST_PATH_LENGTHS,34,0.05,Loop structures for Floyd-Warshall; iteration logic is standard.,0
32,24,SHORTEST_PATH_LENGTHS,39,0.05,Closing brackets of loops; no effect.,0
32,25,SHORTEST_PATH_LENGTHS,40,0.05,Closing brackets of loops; no effect.,0
32,26,SHORTEST_PATH_LENGTHS,41,0.05,Closing brackets of loops; no effect.,0
32,27,SHORTEST_PATH_LENGTHS,42,0.05,Correctly returns the computed length_by_path.,0
32,28,SHORTEST_PATH_LENGTHS,43,0.05,Correctly returns the computed length_by_path.,0
32,29,SHORTEST_PATH_LENGTHS,1,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,30,SHORTEST_PATH_LENGTHS,2,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,31,SHORTEST_PATH_LENGTHS,3,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,32,SHORTEST_PATH_LENGTHS,4,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,33,SHORTEST_PATH_LENGTHS,5,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,34,SHORTEST_PATH_LENGTHS,6,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,35,SHORTEST_PATH_LENGTHS,7,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,36,SHORTEST_PATH_LENGTHS,8,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,37,SHORTEST_PATH_LENGTHS,9,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,38,SHORTEST_PATH_LENGTHS,10,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,39,SHORTEST_PATH_LENGTHS,11,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,40,SHORTEST_PATH_LENGTHS,12,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,41,SHORTEST_PATH_LENGTHS,13,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,42,SHORTEST_PATH_LENGTHS,14,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,43,SHORTEST_PATH_LENGTHS,15,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,44,SHORTEST_PATH_LENGTHS,16,0.0,"Package declaration, imports, comments, and class signature; no impact on logic.",0
32,45,SHORTEST_PATH_LENGTHS,44,0.0,Blank separator line.,0
32,46,SHORTEST_PATH_LENGTHS,52,0.0,File end; no operation.,0
32,47,SHORTEST_PATH_LENGTHS,26,0.0,Blank,0
32,48,SHORTEST_PATH_LENGTHS,27,0.0,Blank,0
32,49,SHORTEST_PATH_LENGTHS,29,0.0,Blank,0
32,50,SHORTEST_PATH_LENGTHS,30,0.0,Blank,0
32,51,SHORTEST_PATH_LENGTHS,31,0.0,Blank,0
32,52,SHORTEST_PATH_LENGTHS,51,0.0,Blank,0
33,1,SHORTEST_PATHS,30,1.0,"Critical logic error: updating weight_by_edge instead of weight_by_node, causing wrong shortest path computation.",1
33,2,SHORTEST_PATHS,16,0.9,Signature of the method; defines how weight_by_edge is used; wrong assumptions propagate here.,0
33,3,SHORTEST_PATHS,24,0.8,Outer loop over node size; repeated relaxations but wrong update target inside.,0
33,4,SHORTEST_PATHS,26,0.8,Involved in faulty weight calculation: updating based on wrong values.,0
33,5,SHORTEST_PATHS,31,0.8,Loop body affected by miscalculated updates in weight_by_edge.,0
33,6,SHORTEST_PATHS,29,0.7,"Misused access: should update target node's weight, not use edge weights this way.",0
33,7,SHORTEST_PATHS,28,0.7,Misleading addition: adding edge weight to source node distance but not properly updating node distance.,0
33,8,SHORTEST_PATHS,25,0.7,"Loop over edges correctly set up, but the operations inside are wrong.",0
33,9,SHORTEST_PATHS,17,0.6,"Initialization of weight_by_node; correct, but without correct updating later, initial INF remains.",0
33,10,SHORTEST_PATHS,18,0.6,Iterates edges to initialize nodes; correct in idea but indirectly affected by update flaws.,0
33,11,SHORTEST_PATHS,19,0.6,Setting destination nodes' distance to INF; harmless but indirectly related to failure.,0
33,12,SHORTEST_PATHS,20,0.6,Setting source nodes' distance to INF; similarly harmless but incomplete protection.,0
33,13,SHORTEST_PATHS,23,0.4,"Correctly setting source distance to 0, but downstream code fails to properly relax other nodes.",0
33,14,SHORTEST_PATHS,32,0.3,Closing brace of nested loops; low impact but wraps incorrect internal logic.,0
33,15,SHORTEST_PATHS,33,0.3,"Correct return statement of weight_by_node, but wrong internal data was built.",0
33,16,SHORTEST_PATHS,35,0.2,"Mathematical operation on wrong values, thus not major error source but misused context.",0
33,17,SHORTEST_PATHS,36,0.2,Auxiliary call for sum in shortest path check; safe function but wrong application of result.,0
33,18,SHORTEST_PATHS,37,0.2,Part of miscalculated update; used in minimum operation incorrectly.,0
33,19,SHORTEST_PATHS,38,0.2,"Putting incorrect update length into map, continuation of mistake initiated earlier.",0
33,20,SHORTEST_PATHS,39,0.1,"End of main algorithm loops; no logic, just syntax closure.",0
33,21,SHORTEST_PATHS,40,0.1,"Start of function ending; no logic, just structural.",0
33,22,SHORTEST_PATHS,41,0.1,Final return; correct syntactically but on wrong data.,0
33,23,SHORTEST_PATHS,3,0.0,Import statement; no effect on logic.,0
33,24,SHORTEST_PATHS,4,0.0,File comments and JavaDoc; no effect on logic.,0
33,25,SHORTEST_PATHS,5,0.0,File comments and JavaDoc; no effect on logic.,0
33,26,SHORTEST_PATHS,6,0.0,File comments and JavaDoc; no effect on logic.,0
33,27,SHORTEST_PATHS,7,0.0,File comments and JavaDoc; no effect on logic.,0
33,28,SHORTEST_PATHS,8,0.0,File comments and JavaDoc; no effect on logic.,0
33,29,SHORTEST_PATHS,1,0.0,Package and imports; unrelated.,0
33,30,SHORTEST_PATHS,2,0.0,Package and imports; unrelated.,0
33,31,SHORTEST_PATHS,9,0.0,Class declaration; correct structure.,0
33,32,SHORTEST_PATHS,11,0.0,INF definition and comment; correct and necessary.,0
33,33,SHORTEST_PATHS,12,0.0,INF definition and comment; correct and necessary.,0
33,34,SHORTEST_PATHS,13,0.0,INF definition and comment; correct and necessary.,0
33,35,SHORTEST_PATHS,14,0.0,Blank line; no effect.,0
33,36,SHORTEST_PATHS,15,0.0,Start of shortest_paths method; no issue in signature.,0
33,37,SHORTEST_PATHS,10,0.0,Blank,0
33,38,SHORTEST_PATHS,21,0.0,Blank,0
33,39,SHORTEST_PATHS,22,0.0,Blank,0
33,40,SHORTEST_PATHS,27,0.0,Blank,0
33,41,SHORTEST_PATHS,34,0.0,Blank,0
33,42,SHORTEST_PATHS,42,0.0,Blank,0
33,43,SHORTEST_PATHS,43,0.0,Blank,0
33,44,SHORTEST_PATHS,44,0.0,Blank,0
33,45,SHORTEST_PATHS,45,0.0,Blank,0
33,46,SHORTEST_PATHS,46,0.0,Blank,0
33,47,SHORTEST_PATHS,47,0.0,Blank,0
33,48,SHORTEST_PATHS,48,0.0,Blank,0
33,49,SHORTEST_PATHS,49,0.0,Blank,0
33,50,SHORTEST_PATHS,50,0.0,Blank,0
33,51,SHORTEST_PATHS,51,0.0,Blank,0
33,52,SHORTEST_PATHS,52,0.0,Blank,0
33,53,SHORTEST_PATHS,53,0.0,Blank,0
33,54,SHORTEST_PATHS,54,0.0,Blank,0
33,55,SHORTEST_PATHS,55,0.0,Blank,0
33,56,SHORTEST_PATHS,56,0.0,Blank,0
33,57,SHORTEST_PATHS,57,0.0,Blank,0
33,58,SHORTEST_PATHS,58,0.0,Blank,0
33,59,SHORTEST_PATHS,59,0.0,Blank,0
33,60,SHORTEST_PATHS,60,0.0,Blank,0
33,61,SHORTEST_PATHS,61,0.0,Blank,0
33,62,SHORTEST_PATHS,62,0.0,Blank,0
33,63,SHORTEST_PATHS,63,0.0,Blank,0
34,1,SHUNTING_YARD,32,1.0,No push of the current operator after popping; core bug.,0
34,2,SHUNTING_YARD,33,0.9,Exit else block without pushing operator; worsens problem.,1
34,3,SHUNTING_YARD,28,0.8,Handling operator tokens; no operator push after popping.,0
34,4,SHUNTING_YARD,29,0.7,Casting token to String for operator processing.,0
34,5,SHUNTING_YARD,30,0.7,While-loop to pop higher precedence operators; missing subsequent operator push.,0
34,6,SHUNTING_YARD,31,0.7,"Pop operators from stack to output; ok, but incomplete flow.",0
34,7,SHUNTING_YARD,24,0.2,Start for-each loop over tokens; context of main logic.,0
34,8,SHUNTING_YARD,36,0.2,While-loop to flush any remaining operators; correct but operating on incomplete stack.,0
34,9,SHUNTING_YARD,25,0.1,"Type check if token is Integer; narrow handling, no Double support.",0
34,10,SHUNTING_YARD,1,0.0,Package declaration; no logical issues.,0
34,11,SHUNTING_YARD,2,0.0,Import java.util.*; necessary for collections.,0
34,12,SHUNTING_YARD,3,0.0,Import java.lang.Math.*; imported but unused here.,0
34,13,SHUNTING_YARD,4,0.0,Comment start for template hint.,0
34,14,SHUNTING_YARD,5,0.0,Comment; no impact on logic.,0
34,15,SHUNTING_YARD,6,0.0,Comment; no impact on logic.,0
34,16,SHUNTING_YARD,7,0.0,Comment end for template hint.,0
34,17,SHUNTING_YARD,8,0.0,Empty line; formatting.,0
34,18,SHUNTING_YARD,9,0.0,JavaDoc comment start.,0
34,19,SHUNTING_YARD,10,0.0,Empty JavaDoc line.,0
34,20,SHUNTING_YARD,11,0.0,JavaDoc @author.,0
34,21,SHUNTING_YARD,12,0.0,JavaDoc comment end.,0
34,22,SHUNTING_YARD,13,0.0,Class definition for SHUNTING_YARD; no issue here.,0
34,23,SHUNTING_YARD,14,0.0,Method signature for shunting_yard.,0
34,24,SHUNTING_YARD,15,0.0,Map initialization for operator precedence.,0
34,25,SHUNTING_YARD,16,0.0,Precedence set for '+'.,0
34,26,SHUNTING_YARD,17,0.0,Precedence set for '-'.,0
34,27,SHUNTING_YARD,18,0.0,Precedence set for '*'.,0
34,28,SHUNTING_YARD,19,0.0,Precedence set for '/'.,0
34,29,SHUNTING_YARD,20,0.0,Empty line for readability.,0
34,30,SHUNTING_YARD,21,0.0,Initialize output list rpntokens.,0
34,31,SHUNTING_YARD,22,0.0,Initialize operator stack opstack.,0
34,32,SHUNTING_YARD,23,0.0,Empty line before loop.,0
34,33,SHUNTING_YARD,26,0.0,Comment acknowledging missing Double handling.,0
34,34,SHUNTING_YARD,27,0.0,Correctly adds numbers to rpntokens.,0
34,35,SHUNTING_YARD,34,0.0,Close for-each loop.,0
34,36,SHUNTING_YARD,35,0.0,Empty line.,0
34,37,SHUNTING_YARD,37,0.0,Pops from stack to output list during flushing.,0
34,38,SHUNTING_YARD,38,0.0,Close flush while-loop.,0
34,39,SHUNTING_YARD,39,0.0,Empty line.,0
34,40,SHUNTING_YARD,40,0.0,Returns final RPN list.,0
34,41,SHUNTING_YARD,41,0.0,Close method definition.,0
34,42,SHUNTING_YARD,42,0.0,Empty line.,0
34,43,SHUNTING_YARD,43,0.0,Close class definition.,0
35,1,SIEVE,41,1.0,"Main fault: Wrong use of any(list_comp()), should be all(list_comp()).",1
35,2,SIEVE,29,0.2,"Method list_comp(n, primes): generates list of divisibility booleans. Important in flow.",0
35,3,SIEVE,15,0.1,Method all() start: correct logic but unused (should be used in main sieve).,0
35,4,SIEVE,22,0.1,"Method any() start: its definition is correct, but wrong function used in sieve logic.",0
35,5,SIEVE,1,0.0,"Package import, no logical issue.",0
35,6,SIEVE,2,0.0,"Utility imports, irrelevant to the bug.",0
35,7,SIEVE,3,0.0,"Math import, not used directly.",0
35,8,SIEVE,4,0.0,Comment block start.,0
35,9,SIEVE,5,0.0,Comment line.,0
35,10,SIEVE,6,0.0,Comment line.,0
35,11,SIEVE,7,0.0,Comment block end.,0
35,12,SIEVE,8,0.0,Blank line.,0
35,13,SIEVE,9,0.0,JavaDoc comment start.,0
35,14,SIEVE,10,0.0,JavaDoc line.,0
35,15,SIEVE,11,0.0,JavaDoc line.,0
35,16,SIEVE,12,0.0,JavaDoc comment end.,0
35,17,SIEVE,13,0.0,"Class declaration, no bug here.",0
35,18,SIEVE,14,0.0,Blank line.,0
35,19,SIEVE,16,0.0,Loop header inside all().,0
35,20,SIEVE,17,0.0,Return false if any value is false (correct behavior).,0
35,21,SIEVE,18,0.0,End of loop body.,0
35,22,SIEVE,19,0.0,Return true if all elements are true.,0
35,23,SIEVE,20,0.0,End of method all().,0
35,24,SIEVE,21,0.0,Blank line.,0
35,25,SIEVE,23,0.0,Loop header inside any().,0
35,26,SIEVE,24,0.0,Return true if any value is true.,0
35,27,SIEVE,25,0.0,End of loop body.,0
35,28,SIEVE,26,0.0,Return false if no true found.,0
35,29,SIEVE,27,0.0,End of method any().,0
35,30,SIEVE,28,0.0,Blank line.,0
35,31,SIEVE,30,0.0,Init list built_comprehension.,0
35,32,SIEVE,31,0.0,For each prime p in primes.,0
35,33,SIEVE,32,0.0,Add n % p > 0 boolean (correct).,0
35,34,SIEVE,33,0.0,End of loop body.,0
35,35,SIEVE,34,0.0,Return built list.,0
35,36,SIEVE,35,0.0,End of method list_comp().,0
35,37,SIEVE,36,0.0,Blank line.,0
35,38,SIEVE,37,0.0,Blank line.,0
35,39,SIEVE,38,0.0,Method sieve(max) start.,0
35,40,SIEVE,39,0.0,Initialize primes list.,0
35,41,SIEVE,40,0.0,For loop from 2 to max.,0
35,42,SIEVE,42,0.0,"If passes, add n to primes.",0
35,43,SIEVE,43,0.0,End of loop body.,0
35,44,SIEVE,44,0.0,End of for loop.,0
35,45,SIEVE,45,0.0,Return primes list.,0
35,46,SIEVE,46,0.0,End of method sieve().,0
35,47,SIEVE,47,0.0,End of class.,0
36,1,SQRT,16,1.0,"Wrong loop termination condition: compares x - approx instead of approx? - x, leading to infinite loop and timeout errors.",1
36,2,SQRT,17,0.7,"Update step could seem suspicious: although the formula is correct for Newton-Raphson, due to wrong loop condition, it never properly converges.",0
36,3,SQRT,14,0.5,"Method signature is correct, but slight suspicion since no input validation on epsilon <= 0, even though precondition expects epsilon > 0.",0
36,4,SQRT,18,0.3,"Transition to next iteration is normal, but only suspicious because it repeats endlessly without a correct exit due to Line 16.",0
36,5,SQRT,15,0.2,"Initial approximation (x/2d) is reasonable but can influence convergence; however, not the primary cause of timeout.",0
36,6,SQRT,19,0.1,"Return statement itself is fine once convergence happens, but suspicious if loop never exits.",0
36,7,SQRT,20,0.0,End of method: no operational logic here.,0
36,8,SQRT,13,0.0,Class declaration: no direct influence on the bug.,0
36,9,SQRT,12,0.0,Closing JavaDoc (author): irrelevant.,0
36,10,SQRT,11,0.0,JavaDoc Tag (@author): irrelevant.,0
36,11,SQRT,10,0.0,JavaDoc Open Comment: irrelevant.,0
36,12,SQRT,9,0.0,Empty Line: no logic.,0
36,13,SQRT,8,0.0,End of comment block: irrelevant.,0
36,14,SQRT,7,0.0,Template comment: irrelevant.,0
36,15,SQRT,6,0.0,Template comment: irrelevant.,0
36,16,SQRT,5,0.0,Template comment: irrelevant.,0
36,17,SQRT,4,0.0,"Import statement (Math): correct, necessary for Math.abs.",0
36,18,SQRT,3,0.0,"Import statement (util): correct, no direct issue.",0
36,19,SQRT,2,0.0,"Import statement (util): correct, no direct issue.",0
36,20,SQRT,1,0.0,Package declaration: no influence on function behavior.,0
36,21,SQRT,21,0.0,Blank,0
37,1,SUBSEQUENCES,15,1.0,"The base case if (k == 0) returns an empty ArrayList instead of [[]], causing critical mismatch with expected outputs for k=0k=0k=0.",0
37,2,SUBSEQUENCES,20,0.95,"Loop boundary i < b+1-k may incorrectly skip iterations when kkk is close to b?a+1b-a+1b?a+1, leading to missing subsequences.",0
37,3,SUBSEQUENCES,22,0.9,"Recursive call to subsequences(i+1, b, k-1) assumes non-empty return; when it returns empty, no sequences are built.",0
37,4,SUBSEQUENCES,23,0.8,Adding i to rest without ensuring rest is properly initialized can propagate incomplete subsequences.,0
37,5,SUBSEQUENCES,16,0.5,The return new ArrayList(); inside base case does not match the expected [[]] structure required for k=0 subsequences.,1
37,6,SUBSEQUENCES,24,0.4,base.add(rest); depends entirely on proper results from recursion; faulty recursion leads to wrong base construction.,0
37,7,SUBSEQUENCES,26,0.4,ret.addAll(base); propagates incorrect or missing sequences if previous errors occur.,0
37,8,SUBSEQUENCES,30,0.2,"The return ret; may return incomplete results if the earlier recursive build is faulty, but by itself it is a symptom, not cause.",0
37,9,SUBSEQUENCES,19,0.1,"Initializing ret = new ArrayList(50); — unlikely problematic, minor initialization detail.",0
37,10,SUBSEQUENCES,21,0.1,Initializing base = new ArrayList(50); — similarly unlikely source of bugs unless recursion errors happen.,0
37,11,SUBSEQUENCES,17,0.05,"Bracket close of base case, no direct logic but included for completeness.",0
37,12,SUBSEQUENCES,18,0.05,"Blank line, no logic.",0
37,13,SUBSEQUENCES,28,0.05,Closing bracket of the for-loop.,0
37,14,SUBSEQUENCES,29,0.05,"Blank line, no logic.",0
37,15,SUBSEQUENCES,31,0.05,Closing bracket of the recursive helper function.,0
37,16,SUBSEQUENCES,14,0.0,Method signature: correct and matches SOFL.,0
37,17,SUBSEQUENCES,13,0.0,Class declaration.,0
37,18,SUBSEQUENCES,12,0.0,Author comment.,0
37,19,SUBSEQUENCES,11,0.0,Author comment.,0
37,20,SUBSEQUENCES,10,0.0,JavaDoc start comment.,0
37,21,SUBSEQUENCES,9,0.0,JavaDoc opening.,0
37,22,SUBSEQUENCES,8,0.0,Blank line.,0
37,23,SUBSEQUENCES,7,0.0,Comment.,0
37,24,SUBSEQUENCES,6,0.0,Comment.,0
37,25,SUBSEQUENCES,5,0.0,Comment.,0
37,26,SUBSEQUENCES,4,0.0,Comment.,0
37,27,SUBSEQUENCES,3,0.0,"import java.util.*;, necessary import.",0
37,28,SUBSEQUENCES,2,0.0,"import java.util.*;, necessary import.",0
37,29,SUBSEQUENCES,1,0.0,package java_programs; — correct placement.,0
37,30,SUBSEQUENCES,25,0.0,Blank,0
37,31,SUBSEQUENCES,27,0.0,Blank,0
37,32,SUBSEQUENCES,32,0.0,Blank,0
38,1,TO_BASE,21,1.0,"Appends the newly computed digit to the end of the result string, causing reversed digit order; should prepend instead.",1
38,2,TO_BASE,24,0.8,Returns the incorrectly built result string without correcting the order; no reversal or adjustment performed.,0
38,3,TO_BASE,18,0.5,The while (num > 0) loop correctly controls iteration but supports the flawed accumulation logic that builds reversed results.,0
38,4,TO_BASE,19,0.2,"Correctly computes the remainder (i = num % b), but used in flawed string assembly afterward.",0
38,5,TO_BASE,20,0.2,"Correct floor division (num = num / b), logically fine but enables repeated wrong ordering without fixing the accumulation.",0
38,6,TO_BASE,15,0.1,"Initializes result = """", which is correct itself, but interacts with faulty accumulation later.",0
38,7,TO_BASE,16,0.1,"Correctly defines the base alphabet, not directly problematic, but depends on how it’s used.",0
38,8,TO_BASE,14,0.05,Method signature; correct and matches the intended functionality according to SOFL.,0
38,9,TO_BASE,13,0.0,"Class declaration, not suspicious.",0
38,10,TO_BASE,1,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,11,TO_BASE,2,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,12,TO_BASE,3,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,13,TO_BASE,4,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,14,TO_BASE,5,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,15,TO_BASE,6,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,16,TO_BASE,7,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,17,TO_BASE,8,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,18,TO_BASE,9,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,19,TO_BASE,10,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,20,TO_BASE,11,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,21,TO_BASE,12,0.0,"Package, imports, comments, class headers — no influence on logic error.",0
38,22,TO_BASE,17,0.0,Blank,0
38,23,TO_BASE,22,0.0,Blank,0
38,24,TO_BASE,23,0.0,Blank,0
38,25,TO_BASE,25,0.0,Blank,0
38,26,TO_BASE,26,0.0,Blank,0
39,1,TOPOLOGICAL_ORDERING,17,1.0,"Critical logic flaw: Should check predecessors not successors, violating topological order requirements.",1
39,2,TOPOLOGICAL_ORDERING,16,0.9,nextNode.getSuccessors() retrieved here misleads the control condition at line 17; involved in misinterpretation.,0
39,3,TOPOLOGICAL_ORDERING,18,0.8,Incorrect nodes added due to wrong check in line 17; impacts node growth of ordered list.,0
39,4,TOPOLOGICAL_ORDERING,19,0.7,"Increments listSize without ensuring correctness of newly added node, causing fragile termination control.",0
39,5,TOPOLOGICAL_ORDERING,14,0.6,The main iteration over orderedNodes size; susceptible to faulty size growth from line 19.,0
39,6,TOPOLOGICAL_ORDERING,7,0.5,Starts iterating over graph nodes but may miss nodes whose predecessors aren't properly evaluated.,0
39,7,TOPOLOGICAL_ORDERING,5,0.3,"Method signature; conceptually correct, but its internal fulfillment (ordering correctness) fails.",0
39,8,TOPOLOGICAL_ORDERING,15,0.2,Fetches orderedNodes.get(i) normally; dependency relies on whether earlier nodes were correctly appended.,0
39,9,TOPOLOGICAL_ORDERING,8,0.2,Correct idea (adding nodes with no predecessors) but indirectly involved in incomplete initialization.,0
39,10,TOPOLOGICAL_ORDERING,9,0.1,"Safe addition of nodes initially, but chain effect later leads to incompleteness.",0
39,11,TOPOLOGICAL_ORDERING,23,0.1,Final return is correct syntactically; semantic issue arises earlier.,0
39,12,TOPOLOGICAL_ORDERING,6,0.05,orderedNodes initialization is normal; problem is logical not structural.,0
39,13,TOPOLOGICAL_ORDERING,13,0.05,List size initialization; unproblematic but impacted by wrong node addition.,0
39,14,TOPOLOGICAL_ORDERING,24,0.0,Method close; unrelated to fault directly.,0
39,15,TOPOLOGICAL_ORDERING,25,0.0,Class end; safe.,0
39,16,TOPOLOGICAL_ORDERING,4,0.0,Class declaration; no impact.,0
39,17,TOPOLOGICAL_ORDERING,1,0.0,Package and import statements; irrelevant to logic.,0
39,18,TOPOLOGICAL_ORDERING,2,0.0,Package and import statements; irrelevant to logic.,0
39,19,TOPOLOGICAL_ORDERING,3,0.0,Package and import statements; irrelevant to logic.,0
39,20,TOPOLOGICAL_ORDERING,10,0.0,Blank,0
39,21,TOPOLOGICAL_ORDERING,11,0.0,Blank,0
39,22,TOPOLOGICAL_ORDERING,12,0.0,Blank,0
39,23,TOPOLOGICAL_ORDERING,20,0.0,Blank,0
39,24,TOPOLOGICAL_ORDERING,21,0.0,Blank,0
39,25,TOPOLOGICAL_ORDERING,22,0.0,Blank,0
40,1,WRAP,32,1.0,return lines; — Returns an incomplete lines list because remaining text not appended after loop.,1
40,2,WRAP,22,0.95,"while (text.length() > cols) — Loop stops once text.length() <= cols, but doesn't handle remaining text afterward.",0
40,3,WRAP,29,0.9,lines.add(line); — Only adds lines within loop; missing appending leftover text after the loop.,0
40,4,WRAP,23,0.8,"int end = text.lastIndexOf("" "", cols); — When no space is found, fallback logic may be correct, but interaction with remaining text mishandled.",0
40,5,WRAP,28,0.75,"text = text.substring(end); — Shrinks text after slicing, but if end == text.length() or 0, edge cases not carefully handled.",0
40,6,WRAP,27,0.7,"line = text.substring(0,end); — Might slice incorrectly if end logic has problems (especially when end == cols).",0
40,7,WRAP,24,0.3,if (end == -1) { end = cols; } — Fallback behavior for no-space scenario; fallback itself is correct but needs better integration.,0
40,8,WRAP,30,0.1,"} — End of while loop; not directly wrong, but loop boundary mismanagement affects correctness.",0
40,9,WRAP,19,0.05,"String line; — Line variable itself is fine, but related to missing append outside loop.",0
40,10,WRAP,18,0.05,"ArrayList<String> lines = new ArrayList<String>(); — Normal initialization, not suspicious.",0
40,11,WRAP,20,0.0,{ and } — Normal structural braces.,0
40,12,WRAP,21,0.0,{ and } — Normal structural braces.,0
40,13,WRAP,1,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,14,WRAP,2,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,15,WRAP,3,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,16,WRAP,4,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,17,WRAP,5,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,18,WRAP,6,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,19,WRAP,7,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,20,WRAP,8,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,21,WRAP,9,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,22,WRAP,10,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,23,WRAP,11,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,24,WRAP,12,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,25,WRAP,13,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,26,WRAP,14,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,27,WRAP,15,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,28,WRAP,16,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,29,WRAP,17,0.0,"Package, import, comments, class declaration, main method — No logical issues; unrelated to wrap method.",0
40,30,WRAP,31,0.0,blank line,0
40,31,WRAP,25,0.0,Blank,0
40,32,WRAP,26,0.0,Blank,0
40,33,WRAP,33,0.0,Blank,0
40,34,WRAP,34,0.0,Blank,0
